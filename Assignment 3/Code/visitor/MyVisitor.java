//
// Generated by JTB 1.3.2
//

package visitor;
import syntaxtree.*;
import java.util.*;
import java.io.PrintWriter;

/**
 * Provides default methods which visit each node in the tree in depth-first
 * order.  Your visitors may extend this class.
 */
public class MyVisitor<A> implements GJVoidVisitor<A> {
   //
   // Auto class visitors--probably don't need to be overridden.
   //
   String meet_of_vals(String a,String b)
   {
      if(a.equals("bottom") || b.equals("bottom"))
         return "bottom";
      else if(a.equals("top"))
         return b;
      else if(b.equals("top"))
         return a;
      else 
      {
         if(a.equals(b))
            return a;
         else
            return "bottom";
      }
   }
   class ConstantNode
   {
      public Hashtable<String,String> int_lattice_values;
      public Hashtable<String,String> bool_lattice_values;
      public ArrayList<ConstantNode> successors;
      public ArrayList<ConstantNode> predecessors;
      public boolean executable;
      public String conditional_id;
      public boolean join_node;
      public boolean expr_eval;
      public String id1;
      public String id2;
      public String id_update;
      public char operation;
      public int total_temps;
      public ConstantNode()
      {
         int_lattice_values = new Hashtable<String,String>();
         bool_lattice_values = new Hashtable<String,String>();
         successors = new ArrayList<ConstantNode>();
         predecessors = new ArrayList<ConstantNode>();
         executable = false;
         conditional_id = null;
         join_node = false;
         expr_eval = false;
         total_temps = 0;
      }
      public ConstantNode(ConstantNode c)
      {
         this.int_lattice_values = new Hashtable<String,String>();
         this.bool_lattice_values = new Hashtable<String,String>();
         this.successors = new ArrayList<ConstantNode>();
         this.predecessors = new ArrayList<ConstantNode>();
         this.executable = false;
         this.conditional_id = null;
         this.join_node = false;
         this.expr_eval = false;
         this.total_temps = 0;
         c.bool_lattice_values.forEach((k,v) -> {
            this.bool_lattice_values.put(k,v);
         });
         c.int_lattice_values.forEach((k,v) -> {
            this.int_lattice_values.put(k,v);
         });
      }
   }
   boolean equal_lattice_values(Hashtable<String,String> a,Hashtable<String,String> b)
   {
      if(a == null || b == null)
         return false;
      if(a.size() != b.size())
         return false;
      Iterator<String> it = a.keySet().iterator();
      while(it.hasNext())
      {
         String s = it.next();
         if(!b.containsKey(s))
            return false;
         else if(!(a.get(s).equals(b.get(s))))
            return false;
      }
      return true;
   }
   boolean equal_exec(Hashtable<ConstantNode,Boolean> a,Hashtable<ConstantNode,Boolean> b)
   {
      if(a == null || b == null)
         return false;
      if(a.size() != b.size())
         return false;
      Iterator<ConstantNode> it = a.keySet().iterator();
      while(it.hasNext())
      {
         ConstantNode n = it.next();
         boolean c1 = a.get(n);
         boolean c2 = (b.containsKey(n))?b.get(n):!c1;
         if(c1 != c2)
            return false;
      }
      return true;
   }
   Hashtable<String,String> meet(Hashtable<String,String> a,Hashtable<String,String> b)
   {
      Hashtable<String,String> o = new Hashtable<String,String>();
      if(a == null)
      {
         Iterator<String> it = b.keySet().iterator();
         while(it.hasNext())
         {
            String s = it.next();
            o.put(s,b.get(s));
         }
         return o;
      }
      else if(b == null)
      {
         Iterator<String> it = a.keySet().iterator();
         while(it.hasNext())
         {
            String s = it.next();
            o.put(s,a.get(s));
         }
         return o;
      }
      Iterator<String> it = a.keySet().iterator();
      while(it.hasNext())
      {
         String s = it.next();
         o.put(s,meet_of_vals(a.get(s),b.get(s)));
      }
      return o;
   }
   String re_evaluate(ConstantNode n)
   {
      char c = n.operation;
      String res = "bottom";
      if(c == '&')
      {
         String id1 = n.id1;
         String id2 = n.id2;
         id1 = n.bool_lattice_values.containsKey(id1)?n.bool_lattice_values.get(id1):"bottom";
         id2 = n.bool_lattice_values.containsKey(id2)?n.bool_lattice_values.get(id2):"bottom";
         if(id1.equals("bottom"))
         {
            if(id2.equals("false"))
               res = "false";
            else
               res = "bottom";
         }
         else if(id2.equals("bottom"))
         {
            if(id1.equals("false"))
               res = "false";
            else
               res = "bottom";
         }
         else
         {
            if(!(id1.equals("top")) && (!id2.equals("top")))
               res = Boolean.toString(Boolean.parseBoolean(id1) & Boolean.parseBoolean(id2));
         }
      }
      else if(c == '<')
      {
         String id1 = n.id1;
         String id2 = n.id2;
         id1 = n.int_lattice_values.containsKey(id1)?n.int_lattice_values.get(id1):"bottom";
         id2 = n.int_lattice_values.containsKey(id2)?n.int_lattice_values.get(id2):"bottom";
         if(id1.equals("bottom") || id2.equals("bottom"))
            res = "bottom";
         else
         {
            if(!(id1.equals("top")) && (!id2.equals("top")))
               res = Boolean.toString(Integer.parseInt(id1) < Integer.parseInt(id2));
         }
      }
      else if(c == '=')
      {
         String id1 = n.id1;
         id1 = (n.bool_lattice_values.containsKey(id1))?n.bool_lattice_values.get(id1):"bottom";
         res = id1;
      }
      else if(c == '!')
      {
         String id1 = n.id1;
         id1 = (n.bool_lattice_values.containsKey(id1))?n.bool_lattice_values.get(id1):"bottom";
         id1 = (id1.equals("bottom"))?"bottom":((id1.equals("true"))?"false":"true");
         res = id1;
      }
      else if(c == '@')
      {
         res = n.id1;
      }
      return res;

   }
   void re_evaluate(ConstantNode n,Hashtable<String,String> new_int_lattice_values,Hashtable<String,String> new_bool_lattice_values)
   {
      char c = n.operation;
      String res = "bottom";
      if(c == '+')
      {
         String id1 = n.id1;
         String id2 = n.id2;
         id1 = new_int_lattice_values.containsKey(id1)?new_int_lattice_values.get(id1):"bottom";
         id2 = new_int_lattice_values.containsKey(id2)?new_int_lattice_values.get(id2):"bottom";
         if(id1.equals("bottom") || id2.equals("bottom"))
            res = "bottom";
         else
         {
            if(!(id1.equals("top")) && (!id2.equals("top")))
               res = Integer.toString(Integer.parseInt(id1) + Integer.parseInt(id2));
         }
         if(new_int_lattice_values.containsKey(n.id_update))
            new_int_lattice_values.put(n.id_update,res);
      }
      else if(c == '-')
      {
         String id1 = n.id1;
         String id2 = n.id2;
         id1 = new_int_lattice_values.containsKey(id1)?new_int_lattice_values.get(id1):"bottom";
         id2 = new_int_lattice_values.containsKey(id2)?new_int_lattice_values.get(id2):"bottom";
         if(id1.equals("bottom") || id2.equals("bottom"))
            res = "bottom";
         else
         {
            if(!(id1.equals("top")) && (!id2.equals("top")))
               res = Integer.toString(Integer.parseInt(id1) - Integer.parseInt(id2));
         }
         if(new_int_lattice_values.containsKey(n.id_update))
            new_int_lattice_values.put(n.id_update,res);
      }
      else if(c == '*')
      {
         String id1 = n.id1;
         String id2 = n.id2;
         id1 = new_int_lattice_values.containsKey(id1)?new_int_lattice_values.get(id1):"bottom";
         id2 = new_int_lattice_values.containsKey(id2)?new_int_lattice_values.get(id2):"bottom";
         if(id1.equals("bottom") || id2.equals("bottom"))
            res = "bottom";
         else
         {
            if(!(id1.equals("top")) && (!id2.equals("top")))
               res = Integer.toString(Integer.parseInt(id1) * Integer.parseInt(id2));
         }
         if(new_int_lattice_values.containsKey(n.id_update))
            new_int_lattice_values.put(n.id_update,res);
      }
      else if(c == '<')
      {
         String id1 = n.id1;
         String id2 = n.id2;
         id1 = new_int_lattice_values.containsKey(id1)?new_int_lattice_values.get(id1):"bottom";
         id2 = new_int_lattice_values.containsKey(id2)?new_int_lattice_values.get(id2):"bottom";
         if(id1.equals("bottom") || id2.equals("bottom"))
            res = "bottom";
         else
         {
            if(!(id1.equals("top")) && (!id2.equals("top")))
               res = Boolean.toString(Integer.parseInt(id1) < Integer.parseInt(id2));
         }
         if(new_bool_lattice_values.containsKey(n.id_update))
            new_bool_lattice_values.put(n.id_update,res);
      }
      else if(c == '&')
      {
         String id1 = n.id1;
         String id2 = n.id2;
         id1 = new_bool_lattice_values.containsKey(id1)?new_bool_lattice_values.get(id1):"bottom";
         id2 = new_bool_lattice_values.containsKey(id2)?new_bool_lattice_values.get(id2):"bottom";
         if(id1.equals("bottom"))
         {
            if(id2.equals("false"))
               res = "false";
            else
               res = "bottom";
         }
         else if(id2.equals("bottom"))
         {
            if(id1.equals("false"))
               res = "false";
            else
               res = "bottom";
         }
         else
         {
            if(!(id1.equals("top")) && (!id2.equals("top")))
               res = Boolean.toString(Boolean.parseBoolean(id1) & Boolean.parseBoolean(id2));
         }
         if(new_bool_lattice_values.containsKey(n.id_update))
            new_bool_lattice_values.put(n.id_update,res);
      }
      else if(c == '=')
      {
         String id1 = n.id1;
         id1 = (new_bool_lattice_values.containsKey(id1))?new_bool_lattice_values.get(id1):((new_int_lattice_values.containsKey(id1)?n.int_lattice_values.get(id1):"bottom"));
         if(new_bool_lattice_values.containsKey(n.id_update))
            new_bool_lattice_values.put(n.id_update,id1);
         else if(new_int_lattice_values.containsKey(n.id_update))
            new_int_lattice_values.put(n.id_update,id1);
      }
      else if(c == '@')
      {
         if(n.id1.equals("true") || n.id1.equals("false"))
         {
            if(new_bool_lattice_values.containsKey(n.id_update))
               new_bool_lattice_values.put(n.id_update,n.id1);
         }
         else
         {
            if(new_int_lattice_values.containsKey(n.id_update))
               new_int_lattice_values.put(n.id_update,n.id1);
         }
      }
      else if(c == '!')
      {
         String id1 = n.id1;
         id1 = (new_bool_lattice_values.containsKey(id1))?new_bool_lattice_values.get(id1):"bottom";
         id1 = (id1.equals("bottom"))?"bottom":((id1.equals("true"))?"false":"true");
         if(new_bool_lattice_values.containsKey(n.id_update))
            new_bool_lattice_values.put(n.id_update,id1);
      }
      else if(new_int_lattice_values.containsKey(n.id_update))
         new_int_lattice_values.put(n.id_update,"bottom");
      else if(n.bool_lattice_values.containsKey(n.id_update))
         new_bool_lattice_values.put(n.id_update,"bottom");
   }
   void conditional_prop()
   {
      //run the liveness analysis until convergence
      boolean change = false;
      Hashtable<ConstantNode,Boolean> executable_blocks = new Hashtable<ConstantNode,Boolean>();
      int cnt = 0;
      do
      {
         cnt++;
         change = false;
         //pw.printf("Iteration %d of convergence!\n",cnt);
         Hashtable<ConstantNode,Boolean> ex_bl = new Hashtable<ConstantNode,Boolean>();
         for(int i = 0;i < blocks.size(); i++)
         {
            ConstantNode cn = blocks.get(i);
            Hashtable<String,String> new_int_lattice_values = null;
            Hashtable<String,String> new_bool_lattice_values = null;
            if(cn.executable)
            {
               ex_bl.put(cn,true);
               if(cn.successors.size() == 1)
                  cn.successors.get(0).executable = true;
               else if(cn.successors.size() >= 2)//zero successor node doesn't need to be processed as such
               {
                  //must be a conditional branch
                  String id = cn.conditional_id;
                  //pw.println(cn.bool_lattice_values);
                  if(id != null)
                  {
                     if(cn.bool_lattice_values.containsKey(id))
                     {
                        String v = cn.bool_lattice_values.get(id);
                        if(v.equals("bottom"))
                        {
                           for(ConstantNode succ_node : cn.successors)
                              succ_node.executable = true;
                        }
                        else if(v.equals("true"))
                        {
                           cn.successors.get(0).executable = true;
                           cn.successors.get(1).executable = false;
                        }
                        else//value should be false,so if it is a while statement then eliminate it's predecessor
                        {
                           cn.successors.get(0).executable = false;
                           cn.successors.get(1).executable = true;
                        }
                     }
                     else
                     {
                        for(ConstantNode succ_node : cn.successors)
                           succ_node.executable = true;
                     }
                  }
                  else
                  {
                     //for loop branch
                     String res = re_evaluate(cn);
                     if(res.equals("true"))
                     {
                        cn.successors.get(0).executable = true;
                        cn.successors.get(1).executable = false;
                     }
                     else if(res.equals("false"))
                     {
                        cn.successors.get(0).executable = false;
                        cn.predecessors.get(1).executable = false;//do not include the back edge
                        cn.successors.get(1).executable = true;
                     }
                     else
                     {
                        cn.successors.get(0).executable = true;
                        cn.successors.get(1).executable = true;
                     }
                  }
               }
               new_bool_lattice_values = null;
               new_int_lattice_values = null;
               for(ConstantNode n1 : cn.predecessors)
               {
                  if(!n1.executable)
                     continue;
                  Iterator<String> it = n1.int_lattice_values.keySet().iterator();
                  Hashtable<String,String> h1 = new Hashtable<String,String>();
                  Hashtable<String,String> h2 = new Hashtable<String,String>();
                  while(it.hasNext())
                  {
                     String s = it.next();
                     h1.put(s,n1.int_lattice_values.get(s));
                  }
                  it = n1.bool_lattice_values.keySet().iterator();
                  while(it.hasNext())
                  {
                     String s = it.next();
                     h2.put(s,n1.bool_lattice_values.get(s));
                  }
                  if(n1.expr_eval)
                     re_evaluate(n1,h1,h2);//compute outward flow value over here
                  new_int_lattice_values = meet(new_int_lattice_values,h1);
                  new_bool_lattice_values = meet(new_bool_lattice_values,h2);
               }
               if((new_int_lattice_values != null)&& (!equal_lattice_values(cn.int_lattice_values, new_int_lattice_values)))
               {
                  change = true;
                  cn.int_lattice_values = new_int_lattice_values;
               }
               if((new_bool_lattice_values != null) && (!equal_lattice_values(cn.bool_lattice_values, new_bool_lattice_values)))
               {
                  change = true;
                  cn.bool_lattice_values = new_bool_lattice_values;
               }
            }
         }
         if(!equal_exec(ex_bl, executable_blocks))
         {
            executable_blocks = ex_bl;
            change = true;
         }
      }
      while(change);
      // pw.printf("For %s_%s:\n",current_class,current_function);
      // for(ConstantNode cn: blocks)
      // {
      //    pw.printf("Int vals\n");
      //    pw.println(cn.int_lattice_values);
      //    pw.printf("Bool lattice vals\n");
      //    pw.println(cn.bool_lattice_values);
      // }
   }
   class ClassTable
   {
      Hashtable<String,ArrayList<ConstantNode>> function_liveness;
      public ClassTable()
      {
         function_liveness = new Hashtable<String,ArrayList<ConstantNode>>();
      }
   }
   PrintWriter pw = new PrintWriter(System.out,true);
   Hashtable<String,ClassTable> class_liveness;
   ConstantNode curr_node;
   ArrayList<ConstantNode> blocks;
   String value_of_expr;
   String tokenName;
   String current_class;
   String current_function;
   ClassTable class_object;
   int counter = 0;//which block corresponds to which node?
   int for_count = 0;
   boolean do_not_print;
   public void visit(NodeList n, A argu) {
      int _count=0;
      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
         e.nextElement().accept(this,argu);
         _count++;
      }
   }

   public void visit(NodeListOptional n, A argu) {
      if ( n.present() ) {
         int _count=0;
         for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
            e.nextElement().accept(this,argu);
            _count++;
         }
      }
   }

   public void visit(NodeOptional n, A argu) {
      if ( n.present() )
         n.node.accept(this,argu);
   }

   public void visit(NodeSequence n, A argu) {
      int _count=0;
      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
         e.nextElement().accept(this,argu);
         _count++;
      }
   }

   public void visit(NodeToken n, A argu) {
      tokenName = n.tokenImage;
   }

   //
   // User-generated visitor methods below
   //

   /**
    * f0 -> MainClass()
    * f1 -> ( TypeDeclaration() )*
    * f2 -> <EOF>
    */
   public void visit(Goal n, A argu) {
      int x = Integer.valueOf((Integer)argu);
      if(x == 0)
         class_liveness = new Hashtable<String,ClassTable>();
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
   }

   /**
    * f0 -> "class"
    * f1 -> Identifier()
    * f2 -> "{"
    * f3 -> "public"
    * f4 -> "static"
    * f5 -> "void"
    * f6 -> "main"
    * f7 -> "("
    * f8 -> "String"
    * f9 -> "["
    * f10 -> "]"
    * f11 -> Identifier()
    * f12 -> ")"
    * f13 -> "{"
    * f14 -> ( VarDeclaration() )*
    * f15 -> ( Statement() )*
    * f16 -> "}"
    * f17 -> "}"
    */
   public void visit(MainClass n, A argu) {
      int a = Integer.valueOf((Integer)argu);
      if(a == 0)
      {
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
         current_class = tokenName;
         class_object = new ClassTable();
         n.f2.accept(this, argu);
         n.f3.accept(this, argu);
         n.f4.accept(this, argu);
         n.f5.accept(this, argu);
         n.f6.accept(this, argu);
         n.f7.accept(this, argu);
         n.f8.accept(this, argu);
         n.f9.accept(this, argu);
         n.f10.accept(this, argu);
         n.f11.accept(this, argu);
         n.f12.accept(this, argu);
         n.f13.accept(this, argu);
         ConstantNode entry = new ConstantNode();
         curr_node = entry;
         blocks = new ArrayList<ConstantNode>();
         blocks.add(curr_node);
         curr_node.executable = true;
         current_function = "main";
         for_count = 0;
         n.f14.accept(this, argu);
         n.f15.accept(this, argu);
         n.f16.accept(this, argu);
         n.f17.accept(this, argu);
         ConstantNode exit_node = new ConstantNode(curr_node);
         exit_node.predecessors.add(curr_node);
         curr_node.successors.add(exit_node);
         blocks.add(exit_node);
         entry.total_temps = for_count;
         class_object.function_liveness.put("main",blocks);
         conditional_prop();
         curr_node = null;
         class_liveness.put(current_class,class_object);
         class_object = null;
         current_class = current_function = null;
      }
      else
      {
         for_count = 0;
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
         current_class = tokenName;
         class_object = class_liveness.get(current_class);
         n.f2.accept(this, argu);
         pw.printf("class %s{\n",current_class);
         n.f3.accept(this, argu);
         n.f4.accept(this, argu);
         n.f5.accept(this, argu);
         n.f6.accept(this, argu);
         n.f7.accept(this, argu);
         n.f8.accept(this, argu);
         n.f9.accept(this, argu);
         n.f10.accept(this, argu);
         n.f11.accept(this, argu);
         String id = tokenName;
         n.f12.accept(this, argu);
         pw.printf("public static void main(String [] %s){\n",id);
         current_function = "main";
         blocks = class_object.function_liveness.get(current_function);
         counter = 0;
         curr_node = blocks.get(counter);
         for(int i = 1;i <= curr_node.total_temps;i++)
         {
            pw.printf("boolean __while_temp%d;\n",i);//booleans needed for for loops
         }
         n.f13.accept(this, argu);
         n.f14.accept(this, argu);
         n.f15.accept(this, argu);
         n.f16.accept(this, argu);
         n.f17.accept(this, argu);
         pw.printf("}\n}\n");//end main class definition
      }
   }

   /**
    * f0 -> ClassDeclaration()
    *       | ClassExtendsDeclaration()
    */
   public void visit(TypeDeclaration n, A argu) {
      n.f0.accept(this, argu);
   }

   /**
    * f0 -> "class"
    * f1 -> Identifier()
    * f2 -> "{"
    * f3 -> ( VarDeclaration() )*
    * f4 -> ( MethodDeclaration() )*
    * f5 -> "}"
    */
   public void visit(ClassDeclaration n, A argu) {
      int arg = Integer.valueOf((Integer)argu);
      if(arg == 0)
      {
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
         current_class = tokenName;
         class_object = new ClassTable();
         n.f2.accept(this, argu);
         n.f3.accept(this, argu);
         n.f4.accept(this, argu);
         n.f5.accept(this, argu);
         class_liveness.put(current_class,class_object);
         class_object = null;
         current_class = null;
      }
      else
      {
         n.f0.accept(this,argu);
         n.f1.accept(this,argu);
         current_class = tokenName;
         class_object = class_liveness.get(current_class);
         n.f2.accept(this,argu);
         pw.printf("class %s{\n",current_class);
         n.f3.accept(this,argu);
         n.f4.accept(this,argu);
         n.f5.accept(this,argu);
         pw.printf("}\n");
         current_class = null;
         class_object = null;
      }
   }

   /**
    * f0 -> "class"
    * f1 -> Identifier()
    * f2 -> "extends"
    * f3 -> Identifier()
    * f4 -> "{"
    * f5 -> ( VarDeclaration() )*
    * f6 -> ( MethodDeclaration() )*
    * f7 -> "}"
    */
   public void visit(ClassExtendsDeclaration n, A argu) {
      int arg = Integer.valueOf((Integer)argu);
      if(arg == 0)
      {
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
         current_class = tokenName;
         class_object = new ClassTable();
         n.f2.accept(this, argu);
         n.f3.accept(this, argu);
         n.f4.accept(this, argu);
         n.f5.accept(this, argu);
         n.f6.accept(this, argu);
         n.f7.accept(this, argu);
         class_liveness.put(current_class,class_object);
         class_object = null;
         current_class = null;
      }
      else
      {
         n.f0.accept(this,argu);
         n.f1.accept(this,argu);
         current_class = tokenName;
         class_object = class_liveness.get(current_class);
         n.f2.accept(this,argu);
         n.f3.accept(this,argu);
         String par = tokenName;
         n.f4.accept(this,argu);
         pw.printf("class %s extends %s{\n",current_class,par);
         n.f5.accept(this,argu);
         n.f6.accept(this,argu);
         n.f7.accept(this,argu);
         pw.printf("}\n");
         class_object = null;
         current_class = null;
      }
   }

   /**
    * f0 -> Type()
    * f1 -> Identifier()
    * f2 -> ";"
    */
   public void visit(VarDeclaration n, A argu) {
      int a = Integer.valueOf((Integer)argu);
      if(a == 0)
      {
         n.f0.accept(this, argu);
         String ty = tokenName;
         n.f1.accept(this, argu);
         String id = tokenName;
         if(current_function != null)
         {
            if(ty.equals("boolean"))
               curr_node.bool_lattice_values.put(id,"top");//only function locals are considered
            else if(ty.equals("int"))
               curr_node.int_lattice_values.put(id,"top");
         }
         n.f2.accept(this, argu);
      }
      else
      {
         n.f0.accept(this,argu);
         String ty = tokenName;
         n.f1.accept(this,argu);
         String id = tokenName;
         n.f2.accept(this,argu);
         pw.printf("%s %s;\n",ty,id);
      }
   }

   /**
    * f0 -> "public"
    * f1 -> Type()
    * f2 -> Identifier()
    * f3 -> "("
    * f4 -> ( FormalParameterList() )?
    * f5 -> ")"
    * f6 -> "{"
    * f7 -> ( VarDeclaration() )*
    * f8 -> ( Statement() )*
    * f9 -> "return"
    * f10 -> Identifier()
    * f11 -> ";"
    * f12 -> "}"
    */
   public void visit(MethodDeclaration n, A argu) {
      int arg = Integer.valueOf((Integer)argu);
      if(arg == 0)
      {
         for_count = 0;
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
         String rt = tokenName;
         n.f2.accept(this, argu);
         current_function = tokenName;
         blocks = new ArrayList<ConstantNode>();
         curr_node = new ConstantNode();
         ConstantNode entry = curr_node;
         curr_node.executable = true;
         n.f3.accept(this, argu);
         n.f4.accept(this, argu);
         n.f5.accept(this, argu);
         blocks.add(curr_node);
         n.f6.accept(this, argu);
         n.f7.accept(this, argu);
         n.f8.accept(this, argu);
         n.f9.accept(this, argu);
         n.f10.accept(this, argu);
         n.f11.accept(this, argu);
         ConstantNode exit_node = new ConstantNode(curr_node);
         exit_node.predecessors.add(curr_node);
         curr_node.successors.add(exit_node);
         n.f12.accept(this, argu);
         blocks.add(exit_node);
         entry.total_temps = for_count;
         class_object.function_liveness.put(current_function,blocks);
         conditional_prop();
         current_function = null;
         blocks = null;
      }
      else
      {
         for_count = 0;
         do_not_print = false;
         n.f0.accept(this,argu);
         n.f1.accept(this,argu);
         String rt = tokenName;
         n.f2.accept(this,argu);
         current_function = tokenName;
         blocks = class_object.function_liveness.get(current_function);
         counter = 0;
         curr_node = blocks.get(counter);
         n.f3.accept(this,argu);
         pw.printf("public %s %s(",rt,current_function);
         n.f4.accept(this,argu);
         n.f5.accept(this,argu);
         n.f6.accept(this,argu);
         pw.printf("){\n");
         for(int i = 1;i <= curr_node.total_temps;i++)
         {
            pw.printf("boolean __while_temp%d;\n",i);
         }
         n.f7.accept(this,argu);
         n.f8.accept(this,argu);
         n.f9.accept(this,argu);
         n.f10.accept(this,argu);
         String id = tokenName;
         n.f11.accept(this,argu);
         n.f12.accept(this,argu);
         counter++;
         curr_node = blocks.get(counter);
         if(rt.equals("boolean"))
         {
            if(curr_node.bool_lattice_values.containsKey(id))
            {
               String id1 = curr_node.bool_lattice_values.get(id);
               if(!((id1.equals("top")) || id1.equals("bottom")))
                  id = id1;
            }
         }
         else if(rt.equals("int"))
         {
            if(curr_node.int_lattice_values.containsKey(id))
            {
               String x = curr_node.int_lattice_values.get(id);
               if(!((x.equals("top")) || (x.equals("bottom"))))
               {
                  if(Integer.parseInt(x) >= 0)
                     id = x;
               }
            }
         }
         pw.printf("return %s;\n}\n",id);
      }
   }

   /**
    * f0 -> FormalParameter()
    * f1 -> ( FormalParameterRest() )*
    */
   public void visit(FormalParameterList n, A argu) {
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
   }

   /**
    * f0 -> Type()
    * f1 -> Identifier()
    */
   public void visit(FormalParameter n, A argu) {
      int arg = Integer.valueOf((Integer)argu);
      if(arg == 0)
      {
         n.f0.accept(this, argu);
         String ty = tokenName;
         n.f1.accept(this, argu);
         String id = tokenName;
         if(ty.equals("boolean"))
         {
            curr_node.bool_lattice_values.put(id,"bottom");
         }
         else if(ty.equals("int"))
         {
            curr_node.int_lattice_values.put(id,"bottom");
         }
      }
      else
      {
         n.f0.accept(this,argu);
         String ty = tokenName;
         n.f1.accept(this,argu);
         String id = tokenName;
         pw.printf("%s %s",ty,id);
      }
   }

   /**
    * f0 -> ","
    * f1 -> FormalParameter()
    */
   public void visit(FormalParameterRest n, A argu) {
      int arg = Integer.valueOf((Integer)argu);
      if(arg == 0)
      {
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
      }
      else
      {
         n.f0.accept(this,argu);
         pw.printf(",");
         n.f1.accept(this,argu);
      }
   }

   /**
    * f0 -> ArrayType()
    *       | BooleanType()
    *       | IntegerType()
    *       | Identifier()
    */
   public void visit(Type n, A argu) {
      n.f0.accept(this, argu);
   }

   /**
    * f0 -> "int"
    * f1 -> "["
    * f2 -> "]"
    */
   public void visit(ArrayType n, A argu) {
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      tokenName = "int[]";
   }

   /**
    * f0 -> "boolean"
    */
   public void visit(BooleanType n, A argu) {
      n.f0.accept(this, argu);
      tokenName = "boolean";
   }

   /**
    * f0 -> "int"
    */
   public void visit(IntegerType n, A argu) {
      n.f0.accept(this, argu);
      tokenName = "int";
   }

   /**
    * f0 -> Block()
    *       | AssignmentStatement()
    *       | ArrayAssignmentStatement()
    *       | FieldAssignmentStatement()
    *       | IfStatement()
    *       | WhileStatement()
    *       | ForStatement()
    *       | PrintStatement()
    */
   public void visit(Statement n, A argu) {
      n.f0.accept(this, argu);
   }

   /**
    * f0 -> "{"
    * f1 -> ( Statement() )*
    * f2 -> "}"
    */
   public void visit(Block n, A argu) {
      int arg = Integer.valueOf((Integer)argu);
      if(arg == 0)
      {
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
         n.f2.accept(this, argu);
      }
      else
      {
         n.f0.accept(this, argu);
         pw.printf("{\n");
         n.f1.accept(this, argu);
         n.f2.accept(this, argu);
         pw.printf("}\n");
      }
   }

   /**
    * f0 -> Identifier()
    * f1 -> "="
    * f2 -> Expression()
    * f3 -> ";"
    */
   public void visit(AssignmentStatement n, A argu) {
      int arg = Integer.valueOf((Integer)argu);
      if(arg == 0)
      {
         n.f0.accept(this, argu);
         ConstantNode new_node;
         new_node = new ConstantNode(curr_node);
         curr_node.successors.add(new_node);
         new_node.predecessors.add(curr_node);
         blocks.add(new_node);
         curr_node = new_node;
         curr_node.expr_eval = true;
         String id = tokenName;
         curr_node.id_update = id;
         n.f1.accept(this, argu);
         n.f2.accept(this, argu);
         n.f3.accept(this, argu);
      }
      else
      {
         n.f0.accept(this,argu);
         String id = tokenName;
         n.f1.accept(this,argu);
         counter++;
         curr_node = blocks.get(counter);
         if(!do_not_print)
            pw.printf("%s = ",id);
         n.f2.accept(this,argu);
         n.f3.accept(this,argu);
         if(!do_not_print)
            pw.printf(";\n");
      }
   }

   /**
    * f0 -> Identifier()
    * f1 -> "["
    * f2 -> Identifier()
    * f3 -> "]"
    * f4 -> "="
    * f5 -> Identifier()
    * f6 -> ";"
    */
   public void visit(ArrayAssignmentStatement n, A argu) {
      //no optimisation is possible for array fields except constant prop
      int arg = Integer.valueOf((Integer)argu);
      if(arg == 0)
      {
         n.f0.accept(this, argu);
         ConstantNode new_node = new ConstantNode(curr_node);
         curr_node.successors.add(new_node);
         new_node.predecessors.add(curr_node);
         String ar = tokenName;
         n.f1.accept(this, argu);
         n.f2.accept(this, argu);
         String ind = tokenName;
         n.f3.accept(this, argu);
         n.f4.accept(this, argu);
         n.f5.accept(this, argu);
         String va = tokenName;
         n.f6.accept(this, argu);
         blocks.add(new_node);
         curr_node = new_node;
      }
      else
      {
         counter++;
         curr_node = blocks.get(counter);
         n.f0.accept(this, argu);
         String ar = tokenName;
         n.f1.accept(this, argu);
         n.f2.accept(this, argu);
         String ind = tokenName;
         String x = (curr_node.int_lattice_values.containsKey(ind))?curr_node.int_lattice_values.get(ind):"bottom";
         ind = (x.equals("bottom") || x.equals("top"))?ind:x;
         n.f3.accept(this, argu);
         n.f4.accept(this, argu);
         n.f5.accept(this, argu);
         String va = tokenName;
         String y = (curr_node.int_lattice_values.containsKey(va))?curr_node.int_lattice_values.get(va):"bottom";
         va = (!(y.equals("bottom") || y.equals("top")))?((Integer.parseInt(y) < 0)?va:y):va;
         n.f6.accept(this, argu);
         pw.printf("%s[%s] = %s;\n",ar,ind,va);
      }
   }

   /**
    * f0 -> Identifier()
    * f1 -> "."
    * f2 -> Identifier()
    * f3 -> "="
    * f4 -> Identifier()
    * f5 -> ";"
    */
   public void visit(FieldAssignmentStatement n, A argu) {
      int arg = Integer.valueOf((Integer)argu);
      if(arg == 0)
      {
         ConstantNode new_node = new ConstantNode(curr_node);
         curr_node.successors.add(new_node);
         new_node.predecessors.add(curr_node);
         curr_node = new_node;
         blocks.add(new_node);
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
         n.f2.accept(this, argu);
         n.f3.accept(this, argu);
         n.f4.accept(this, argu);
         String id = tokenName;
         n.f5.accept(this, argu);
      }
      else
      {
         counter++;
         curr_node = blocks.get(counter);
         n.f0.accept(this, argu);
         String ob = tokenName;
         n.f1.accept(this, argu);
         n.f2.accept(this, argu);
         String fl = tokenName;
         n.f3.accept(this, argu);
         n.f4.accept(this, argu);
         String id = tokenName;
         if(curr_node.bool_lattice_values.containsKey(id))
         {
            id = (curr_node.bool_lattice_values.get(id).equals("bottom"))?id:curr_node.bool_lattice_values.get(id);
         }
         else if(curr_node.int_lattice_values.containsKey(id))
         {
            String t = curr_node.int_lattice_values.get(id);
            if(!t.equals("bottom"))
            {
               if((!t.equals("top")) && (Integer.parseInt(t) >= 0))
                  id = t;
            }
         }
         n.f5.accept(this, argu);
         if(!do_not_print)
            pw.printf("%s.%s = %s;\n",ob,fl,id);//if reachable then print it, else do not
      }
   }

   /**
    * f0 -> "if"
    * f1 -> "("
    * f2 -> Identifier()
    * f3 -> ")"
    * f4 -> Statement()
    * f5 -> "else"
    * f6 -> Statement()
    */
   public void visit(IfStatement n, A argu) {
      int arg = Integer.valueOf((Integer)argu);
      if(arg == 0)
      {
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
         n.f2.accept(this, argu);
         String id = tokenName;
         n.f3.accept(this, argu);
         ConstantNode cond_node = new ConstantNode(curr_node);
         curr_node.successors.add(cond_node);
         cond_node.predecessors.add(curr_node);
         ConstantNode final_node = new ConstantNode(curr_node);
         cond_node.conditional_id = id;
         curr_node = cond_node;
         blocks.add(cond_node);
         //curr_node.conditional_branch = true;
         n.f4.accept(this, argu);
         curr_node.successors.add(final_node);
         final_node.predecessors.add(curr_node);
         n.f5.accept(this, argu);
         curr_node = cond_node;
         n.f6.accept(this, argu);
         curr_node.successors.add(final_node);
         final_node.predecessors.add(curr_node);
         final_node.join_node = true;//take meet value later based on the executable nature
         blocks.add(final_node);
         curr_node = final_node;
      }
      else
      {
         counter++;
         n.f0.accept(this,argu);
         n.f1.accept(this,argu);
         n.f2.accept(this,argu);
         String id = tokenName;
         n.f3.accept(this,argu);
         curr_node = blocks.get(counter); 
         if(curr_node.bool_lattice_values.containsKey(id) && (!curr_node.bool_lattice_values.get(id).equals("bottom")))
         {
            pw.printf("if(%s)\n",id);
            n.f4.accept(this,argu);
            n.f5.accept(this,argu);
            pw.printf("else\n");
            n.f6.accept(this,argu);
         }
         else
         {
            boolean x = !do_not_print;
            if(x)
               pw.printf("if(%s)\n",id);
            n.f4.accept(this,argu);
            n.f5.accept(this,argu);
            if(x)
               pw.printf("else\n");
            n.f6.accept(this,argu);
         }
         counter++;//for the join node that results
      }
   }

   /**
    * f0 -> "while"
    * f1 -> "("
    * f2 -> Identifier()
    * f3 -> ")"
    * f4 -> Statement()
    */
   public void visit(WhileStatement n, A argu) {
      int arg = Integer.valueOf((Integer)argu);
      if(arg == 0)
      {
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
         n.f2.accept(this, argu);
         String id = tokenName;
         n.f3.accept(this, argu);
         ConstantNode loop_node = new ConstantNode(curr_node);
         loop_node.predecessors.add(curr_node);
         curr_node.successors.add(loop_node);
         blocks.add(loop_node);
         loop_node.conditional_id = id;
         //loop_node.conditional_branch = true;
         loop_node.join_node = true;
         curr_node = loop_node;
         n.f4.accept(this, argu);
         curr_node.successors.add(loop_node);
         loop_node.predecessors.add(curr_node);
         curr_node = loop_node;
      }
      else
      {
         counter++;
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
         n.f2.accept(this, argu);
         String id = tokenName;
         n.f3.accept(this, argu);
         curr_node = blocks.get(counter);
         String res = "bottom";
         res = (curr_node.bool_lattice_values.containsKey(id))?curr_node.bool_lattice_values.get(id):"bottom";
         if(res.equals("bottom"))
         {
            if(!do_not_print)
               pw.printf("while(%s)\n",id);
            n.f4.accept(this,argu);
         }
         else if(res.equals("true"))
         {
            if(!do_not_print)
               pw.printf("while(true)\n");
            n.f4.accept(this,argu);
         }
         else
         {
            boolean d = do_not_print;
            //do_not_print = true;
            n.f4.accept(this,argu);
            do_not_print = d;
         }
      }
   }

   /**
    * f0 -> "for"
    * f1 -> "("
    * f2 -> Identifier()
    * f3 -> "="
    * f4 -> Expression()
    * f5 -> ";"
    * f6 -> Expression()
    * f7 -> ";"
    * f8 -> Identifier()
    * f9 -> "="
    * f10 -> Expression()
    * f11 -> ")"
    * f12 -> Statement()
    */
   public void visit(ForStatement n, A argu) {//has to be fixed!
      int arg = Integer.valueOf((Integer)argu);
      if(arg == 0)
      {
         for_count++;
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
         n.f2.accept(this, argu);
         String id = tokenName;
         ConstantNode beg = new ConstantNode(curr_node);
         curr_node.successors.add(beg);
         beg.predecessors.add(curr_node);
         beg.expr_eval = true;
         beg.id_update = id;
         curr_node = beg;
         n.f3.accept(this, argu);
         n.f4.accept(this, argu);
         n.f5.accept(this, argu);
         ConstantNode cond = new ConstantNode(curr_node);
         beg.successors.add(cond);
         cond.predecessors.add(beg);
         curr_node = cond;
         n.f6.accept(this, argu);
         n.f7.accept(this,argu);
         n.f8.accept(this, argu);
         ConstantNode upd_node = new ConstantNode(curr_node);
         String id1 = tokenName;
         upd_node.expr_eval = true;
         upd_node.id_update = id1;
         curr_node = upd_node;
         n.f9.accept(this, argu);
         n.f10.accept(this, argu);
         n.f11.accept(this, argu);
         blocks.add(beg);
         blocks.add(cond);
         curr_node = cond;
         n.f12.accept(this, argu);
         blocks.add(upd_node);
         curr_node.successors.add(upd_node);
         upd_node.predecessors.add(curr_node);
         upd_node.successors.add(cond);
         cond.predecessors.add(upd_node);
         curr_node = cond;
      }
      else
      {//change every for loop into a while loop for convenience as per basic block structure.
         for_count++;
         int cur_temp = for_count;
         n.f0.accept(this,argu);
         n.f1.accept(this,argu);
         n.f2.accept(this,argu);
         String id = tokenName;
         counter++;
         curr_node = blocks.get(counter);
         if(!do_not_print)
            pw.printf("%s = ",id);
         n.f3.accept(this,argu);
         n.f4.accept(this,argu);
         n.f5.accept(this,argu);
         if(!do_not_print)
            pw.printf(";\n");
         counter++;
         curr_node = blocks.get(counter);
         String res = re_evaluate(curr_node);
         boolean z = do_not_print;
         if(res.equals("false"));
            //do_not_print = true;
         //ConstantNode cn = curr_node;
         boolean t = !do_not_print;
         if(t)
            pw.printf("__while_temp%d = ",for_count);
         n.f6.accept(this,argu);
         n.f7.accept(this,argu);
         if(t)
            pw.printf(";\n");
         if(t)
            pw.printf("while(__while_temp%d){\n",for_count);
         n.f12.accept(this,argu);//statement first
         n.f8.accept(this,argu);
         String id1 = tokenName;
         n.f9.accept(this,argu);
         counter++;//move basic block
         curr_node = blocks.get(counter);
         if(!do_not_print)
            pw.printf("%s = ",id1);
         n.f10.accept(this,argu);
         n.f11.accept(this,argu);
         if(!do_not_print)
            pw.printf(";\n");
         //ConstantNode cn1 = curr_node;
         //curr_node = cn;
         if(!do_not_print)
         {
            pw.printf("__while_temp%d = ",cur_temp);
            n.f6.accept(this,argu);
            pw.printf(";\n");//update the while temporary post recomputation
         }
         if(t)
            pw.printf("}\n");//while loop
         //curr_node = cn1;
         do_not_print = z;
      }
   }

   /**
    * f0 -> "System.out.println"
    * f1 -> "("
    * f2 -> Identifier()
    * f3 -> ")"
    * f4 -> ";"
    */
   public void visit(PrintStatement n, A argu) {
      int arg = Integer.valueOf((Integer)argu);
      if(arg == 0)
      {
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
         n.f2.accept(this, argu);
         String id = tokenName;
         n.f3.accept(this, argu);
         n.f4.accept(this, argu);
         ConstantNode n1 = new ConstantNode(curr_node);
         curr_node.successors.add(n1);
         n1.predecessors.add(curr_node);
         blocks.add(n1);
         curr_node = n1;
      }
      else
      {
         counter++;
         curr_node = blocks.get(counter);
         n.f0.accept(this,argu);
         n.f1.accept(this,argu);
         n.f2.accept(this,argu);
         String id = tokenName;
         n.f3.accept(this,argu);
         n.f4.accept(this,argu);
         if(curr_node.int_lattice_values.containsKey(id)){
            if(!curr_node.int_lattice_values.get(id).equals("bottom"))
            {
               String t = curr_node.int_lattice_values.get(id);
               if((!t.equals("top") && Integer.parseInt(t) >= 0))
                  id = t;
            }
         }
         if(!do_not_print)
            pw.printf("System.out.println(%s);\n",id);
      }
   }

   /**
    * f0 -> AndExpression()
    *       | CompareExpression()
    *       | PlusExpression()
    *       | MinusExpression()
    *       | TimesExpression()
    *       | ArrayLookup()
    *       | ArrayLength()
    *       | MessageSend()
    *       | PrimaryExpression()
    */
   public void visit(Expression n, A argu) {
      n.f0.accept(this, argu);
   }

   /**
    * f0 -> Identifier()
    * f1 -> "&"
    * f2 -> Identifier()
    */
   public void visit(AndExpression n, A argu) {
      int arg = Integer.valueOf((Integer)argu);
      if(arg == 0)
      {
         n.f0.accept(this, argu);
         String id1 = tokenName;
         n.f1.accept(this, argu);
         n.f2.accept(this, argu);
         String id2 = tokenName;
         curr_node.operation = '&';
         curr_node.id1 = id1;
         curr_node.id2 = id2;
         id1 = (curr_node.bool_lattice_values.containsKey(id1))?curr_node.bool_lattice_values.get(id1):"bottom";
         id2 = (curr_node.bool_lattice_values.containsKey(id1))?curr_node.bool_lattice_values.get(id1):"bottom";
      }
      else
      {
         n.f0.accept(this, argu);
         String id1 = tokenName;
         n.f1.accept(this, argu);
         n.f2.accept(this, argu);
         String id2 = tokenName;
         String id12 = (curr_node.bool_lattice_values.containsKey(id1))?curr_node.bool_lattice_values.get(id1):"bottom";;
         String id22 = (curr_node.bool_lattice_values.containsKey(id2))?curr_node.bool_lattice_values.get(id2):"bottom";;
         if(id12.equals("false") || id22.equals("false"))
         {
            value_of_expr = "false";
         }
         else if(id12.equals("true"))
         {
            value_of_expr = (id22.equals("bottom"))?id2:id22;
         }
         else if(id22.equals("true"))
         {
            value_of_expr = (id12.equals("bottom"))?id1:id12;
         }
         else
            value_of_expr = String.format("%s & %s",id1,id2);
         if(!do_not_print)
            pw.printf("%s",value_of_expr);
      }
   }

   /**
    * f0 -> Identifier()
    * f1 -> "<"
    * f2 -> Identifier()
    */
   public void visit(CompareExpression n, A argu) {
      int arg = Integer.valueOf((Integer)argu);
      if(arg == 0)
      {
         n.f0.accept(this, argu);
         String id1 = tokenName;
         n.f1.accept(this, argu);
         n.f2.accept(this, argu);
         String id2 = tokenName;
         curr_node.operation = '<';
         curr_node.id1 = id1;
         curr_node.id2 = id2;
         id1 = (curr_node.int_lattice_values.containsKey(id1))?curr_node.int_lattice_values.get(id1):"bottom";
         id2 = (curr_node.int_lattice_values.containsKey(id2))?curr_node.int_lattice_values.get(id2):"bottom";
      }
      else
      {
         n.f0.accept(this, argu);
         String id1 = tokenName;
         n.f1.accept(this, argu);
         n.f2.accept(this, argu);
         String id2 = tokenName;
         String id12 = (curr_node.int_lattice_values.containsKey(id1))?curr_node.int_lattice_values.get(id1):"bottom";
         String id22 = (curr_node.int_lattice_values.containsKey(id2))?curr_node.int_lattice_values.get(id2):"bottom";
         if((id12.equals("top")) && (id2.equals("top")))
         {
            value_of_expr = String.format("%s < %s",id1,id2);
         }
         if(id12.equals("bottom"))
         {
            if(id22.equals("bottom") || id22.equals("top"))
               value_of_expr = String.format("%s < %s",id1,id2);
            else if(Integer.parseInt(id22) >= 0)
               value_of_expr = String.format("%s < %s",id1,id22);
            else
               value_of_expr = String.format("%s < %s",id1,id2);
         }
         else if(id22.equals("bottom"))
         {
            if(id12.equals("top"))
               value_of_expr = String.format("%s < %s",id1,id2);
            else if(Integer.parseInt(id12) >= 0)
               value_of_expr = String.format("%s < %s",id12,id2);
            else
               value_of_expr = String.format("%s < %s",id1,id2);
         }
         else
         {
            int x1 = 0;
            int y1 = 0;
            if(!(id12.equals("top")) && (!id22.equals("top")))
            {
               x1 = Integer.parseInt(id12);
               y1 = Integer.parseInt(id22);
            }
            value_of_expr = (x1 < y1)?"true":"false";
         }
         if(!do_not_print)
            pw.printf("%s",value_of_expr);
      }
   }

   /**
    * f0 -> Identifier()
    * f1 -> "+"
    * f2 -> Identifier()
    */
   public void visit(PlusExpression n, A argu) {
      int arg = Integer.valueOf((Integer)argu);
      if(arg == 0)
      {
         n.f0.accept(this, argu);
         String id1 = tokenName;
         n.f1.accept(this, argu);
         n.f2.accept(this, argu);
         String id2 = tokenName;
         curr_node.operation = '+';
         curr_node.id1 = id1;
         curr_node.id2 = id2;
         id1 = (curr_node.int_lattice_values.containsKey(id1))?curr_node.int_lattice_values.get(id1):"bottom";
         id2 = (curr_node.int_lattice_values.containsKey(id2))?curr_node.int_lattice_values.get(id2):"bottom";
      }
      else
      {
         n.f0.accept(this, argu);
         String id1 = tokenName;
         n.f1.accept(this, argu);
         n.f2.accept(this, argu);
         String id2 = tokenName;
         String id12 = (curr_node.int_lattice_values.containsKey(id1))?curr_node.int_lattice_values.get(id1):"bottom";
         String id22 = (curr_node.int_lattice_values.containsKey(id2))?curr_node.int_lattice_values.get(id2):"bottom";
         if(id12.equals("bottom"))
         {
            if(id22.equals("bottom") || id22.equals("top"))
               value_of_expr = String.format("%s + %s",id1,id2);
            else if(Integer.parseInt(id22) >= 0)
               value_of_expr = String.format("%s + %s",id1,id22);
            else
               value_of_expr = String.format("%s - %d",id1,Math.abs(Integer.parseInt(id2)));
         }
         else if(id22.equals("bottom"))
         {
            if(id12.equals("bottom") || id12.equals("top"))
               value_of_expr = String.format("%s + %s",id1,id2);
            else if(Integer.parseInt(id12) >= 0)
               value_of_expr = String.format("%s + %s",id12,id2);
            else
               value_of_expr = String.format("%s - %d",id2,Math.abs(Integer.parseInt(id12)));
         }
         else
         {
            int x1 = -1;
            int y1 = -1;
            boolean z1 = false;
            boolean z2 = false;
            if(!id12.equals("top"))
            {
               x1 = Integer.parseInt(id12);
               z1 = true;
            }
            if(!id22.equals("top"))
            {
               y1 = Integer.parseInt(id22);
               z2 = true;
            }
            if(z1 & z2)
            {
               int z = x1+y1;
               if(z >= 0)  
                  value_of_expr = Integer.toString(z);
               else{
               value_of_expr = String.format("0 - %d",Math.abs(z));
               }
            }
            else if(z1)
            {
               if(x1 >= 0)
                  value_of_expr = String.format("%d + %s",x1,id2);
               else
                  value_of_expr = String.format("%s - %d",id2,Math.abs(x1));
            }
            else if(z2)
            {
               if(y1 >= 0)
                  value_of_expr = String.format("%s + %d",id1,y1);
               else
                  value_of_expr = String.format("%s - %d",id1,Math.abs(y1));
            }
            else
               value_of_expr = String.format("%s + %s",id1,id2);
         }
         if(!do_not_print)
            pw.printf("%s",value_of_expr);
      }
   }

   /**
    * f0 -> Identifier()
    * f1 -> "-"
    * f2 -> Identifier()
    */
   public void visit(MinusExpression n, A argu) {
      int arg = Integer.valueOf((Integer)argu);
      if(arg == 0)
      {
         n.f0.accept(this, argu);
         String id1 = tokenName;
         n.f1.accept(this, argu);
         n.f2.accept(this, argu);
         String id2 = tokenName;
         curr_node.operation = '-';
         curr_node.id1 = id1;
         curr_node.id2 = id2;
         id1 = (curr_node.int_lattice_values.containsKey(id1))?curr_node.int_lattice_values.get(id1):"bottom";
         id2 = (curr_node.int_lattice_values.containsKey(id2))?curr_node.int_lattice_values.get(id2):"bottom";
      }
      else
      {
         n.f0.accept(this, argu);
         String id1 = tokenName;
         n.f1.accept(this, argu);
         n.f2.accept(this, argu);
         String id2 = tokenName;
         String id12 = (curr_node.int_lattice_values.containsKey(id1))?curr_node.int_lattice_values.get(id1):"bottom";
         String id22 = (curr_node.int_lattice_values.containsKey(id2))?curr_node.int_lattice_values.get(id2):"bottom";
         if(id12.equals("bottom"))
         {
            if(id22.equals("bottom")||id22.equals("top"))
               value_of_expr = String.format("%s - %s",id1,id2);
            else if(Integer.parseInt(id22) >= 0)
               value_of_expr = String.format("%s - %s",id1,id22);
            else
               value_of_expr = String.format("%s + %d",id1,Math.abs(Integer.parseInt(id22)));
         }
         else if(id22.equals("bottom"))
         {
            if(id12.equals("bottom")||id12.equals("top"))
               value_of_expr = String.format("%s - %s",id1,id2);
            else if(Integer.parseInt(id12) >= 0)
               value_of_expr = String.format("%s - %s",id12,id2);
            else
               value_of_expr = String.format("%s - %s",id1,id2);
         }
         else
         {
            int x1 = -1;
            int y1 = -1;
            boolean z1 = false;
            boolean z2 = false;
            if(!id12.equals("top"))
            {
               x1 = Integer.parseInt(id12);
               z1 = true;
            }
            if(!id22.equals("top"))
            {
               y1 = Integer.parseInt(id22);
               z2 = true;
            }

            if(z1 & z2)
            {
               int z = x1-y1;
               if(z >= 0)  
                  value_of_expr = Integer.toString(z);
               else{
               value_of_expr = String.format("0 - %d",Math.abs(z));
               }
            }
            else if(z1)
            {
               if(x1 >= 0)
                  value_of_expr = String.format("%d - %s",x1,id2);
               else
                  value_of_expr = String.format("%s - %s",id1,id2);
            }
            else if(z2)
            {
               if(y1 >= 0)
                  value_of_expr = String.format("%s - %d",id1,y1);
               else
                  value_of_expr = String.format("%s + %d",id1,Math.abs(y1));
            }
            else
               value_of_expr = String.format("%s - %s",id1,id2);
         }
         if(!do_not_print)
            pw.printf("%s",value_of_expr);
      }
   }

   /**
    * f0 -> Identifier()
    * f1 -> "*"
    * f2 -> Identifier()
    */
   public void visit(TimesExpression n, A argu) {
      int arg = Integer.valueOf((Integer)argu);
      if(arg == 0)
      {
         n.f0.accept(this, argu);
         String id1 = tokenName;
         n.f1.accept(this, argu);
         n.f2.accept(this, argu);
         String id2 = tokenName;
         curr_node.operation = '*';
         curr_node.id1 = id1;
         curr_node.id2 = id2;
         id1 = (curr_node.int_lattice_values.containsKey(id1))?curr_node.int_lattice_values.get(id1):"bottom";
         id2 = (curr_node.int_lattice_values.containsKey(id2))?curr_node.int_lattice_values.get(id2):"bottom";
      }
      else
      {
         n.f0.accept(this, argu);
         String id1 = tokenName;
         n.f1.accept(this, argu);
         n.f2.accept(this, argu);
         String id2 = tokenName;
         String id12 = (curr_node.int_lattice_values.containsKey(id1))?curr_node.int_lattice_values.get(id1):"bottom";
         String id22 = (curr_node.int_lattice_values.containsKey(id2))?curr_node.int_lattice_values.get(id2):"bottom";
         if(id12.equals("bottom"))
         {
            if(id22.equals("bottom")||id22.equals("top"))
               value_of_expr = String.format("%s * %s",id1,id2);
            else if(Integer.parseInt(id22) >= 0)
               value_of_expr = String.format("%s * %s",id1,id22);
            else
               value_of_expr = String.format("%s * %s",id1,id2);
         }
         else if(id22.equals("bottom"))
         {
            if(id12.equals("bottom")||id12.equals("top"))
               value_of_expr = String.format("%s * %s",id1,id2);
            else if(Integer.parseInt(id12) >= 0)
               value_of_expr = String.format("%s * %s",id12,id2);
            else
               value_of_expr = String.format("%s * %s",id1,id2);
         }
         else
         {
            int x1 = -1;
            int y1 = -1;
            boolean z1 = false;
            boolean z2 = false;
            if(!id12.equals("top"))
            {
               x1 = Integer.parseInt(id12);
               z1 = true;
            }
            if(!id22.equals("top"))
            {
               y1 = Integer.parseInt(id22);
               z2 = true;
            }
            if(z1 & z2)
            {
               int z = x1*y1;
               if(z >= 0)  
                  value_of_expr = Integer.toString(z);
               else{
               value_of_expr = String.format("0 - %d",Math.abs(z));
               }
            }
            else if(z1)
            {
               if(x1 >= 0)
                  value_of_expr = String.format("%d * %s",x1,id2);
               else
                  value_of_expr = String.format("%s * %s",id1,id2);
            }
            else if(z2)
            {
               if(y1 >= 0)
                  value_of_expr = String.format("%s * %d",id1,y1);
               else
                  value_of_expr = String.format("%s * %s",id1,id2);
            }
            else
               value_of_expr = String.format("%s * %s",id1,id2);
         }
         if(!do_not_print)
            pw.printf("%s",value_of_expr);
      }
   }

   /**
    * f0 -> Identifier()
    * f1 -> "["
    * f2 -> Identifier()
    * f3 -> "]"
    */
   public void visit(ArrayLookup n, A argu) {
      int arg = Integer.valueOf((Integer)argu);
      if(arg == 0)
      {
         n.f0.accept(this, argu);
         String id1 = tokenName;
         n.f1.accept(this, argu);
         n.f2.accept(this, argu);
         String id2 = tokenName;
         n.f3.accept(this, argu);
         value_of_expr = "bottom";
      }
      else
      {
         n.f0.accept(this,argu);
         String id1 = tokenName;
         n.f1.accept(this, argu);
         n.f2.accept(this, argu);
         String id2 = tokenName;
         n.f3.accept(this, argu);
         if(curr_node.int_lattice_values.containsKey(id2))
         {
            String t = curr_node.int_lattice_values.get(id2);
            if(!(t.equals("top")) && !(t.equals("bottom")))
            {
               id2 = t;//guaranteed to be positive
            }
         }
         value_of_expr = String.format("%s[%s]",id1,id2);
         if(!do_not_print)
            pw.printf("%s",value_of_expr);
         value_of_expr = "bottom";
      }
   }

   /**
    * f0 -> Identifier()
    * f1 -> "."
    * f2 -> "length"
    */
   public void visit(ArrayLength n, A argu) {
      int arg = Integer.valueOf((Integer)argu);
      if(arg == 0)
      {
         n.f0.accept(this, argu);
         String id = tokenName;
         n.f1.accept(this, argu);
         n.f2.accept(this, argu);
         value_of_expr = "bottom";
      }
      else
      {
         n.f0.accept(this, argu);
         String id = tokenName;
         n.f1.accept(this, argu);
         n.f2.accept(this, argu);
         value_of_expr = "bottom";
         if(!do_not_print)
            pw.printf("%s.length",id);
      }
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "."
    * f2 -> Identifier()
    * f3 -> "("
    * f4 -> ( ArgList() )?
    * f5 -> ")"
    */
   public void visit(MessageSend n, A argu) {
      int arg = Integer.valueOf((Integer)argu);
      if(arg == 0)
      {
         n.f0.accept(this, argu);
         String id = value_of_expr;
         n.f1.accept(this, argu);
         n.f2.accept(this, argu);
         String fn_name = tokenName;
         n.f3.accept(this, argu);
         n.f4.accept(this, argu);
         n.f5.accept(this, argu);
         curr_node.operation = '~';//do not confuse primary expression here
         value_of_expr = "bottom";
      }
      else
      {
         n.f0.accept(this, argu);
         String id = value_of_expr;
         n.f1.accept(this, argu);
         n.f2.accept(this, argu);
         String fn_name = tokenName;
         if(!do_not_print)
            pw.printf(".%s(",fn_name);
         n.f3.accept(this, argu);
         n.f4.accept(this, argu);
         n.f5.accept(this, argu);
         if(!do_not_print)
            pw.printf(")");
         value_of_expr = "bottom";
      }
   }

   /**
    * f0 -> Identifier()
    * f1 -> ( ArgRest() )*
    */
   public void visit(ArgList n, A argu) {
      int arg = Integer.valueOf((Integer)argu);
      if(arg == 0)
      {
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
      }
      else
      {
         n.f0.accept(this, argu);
         String id = tokenName;
         if(curr_node.bool_lattice_values.containsKey(id))
            id = ((curr_node.bool_lattice_values.get(id).equals("bottom")) || (curr_node.bool_lattice_values.get(id).equals("top")))?id:curr_node.bool_lattice_values.get(id);
         else if(curr_node.int_lattice_values.containsKey(id))
         {
            String t = curr_node.int_lattice_values.get(id);
            if(!t.equals("bottom") && !t.equals("top"))
            {
               if(Integer.parseInt(t) >= 0)
                  id = t;
            }
         }
         if(!do_not_print)
            pw.printf("%s",id);
         n.f1.accept(this, argu);
      }
   }

   /**
    * f0 -> ","
    * f1 -> Identifier()
    */
   public void visit(ArgRest n, A argu) {
      int arg = Integer.valueOf((Integer)argu);
      if(arg == 0)
      {
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
      }
      else
      {
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
         String id = tokenName;
         if(curr_node.bool_lattice_values.containsKey(id))
         id = ((curr_node.bool_lattice_values.get(id).equals("bottom")) || (curr_node.bool_lattice_values.get(id).equals("top")))?id:curr_node.bool_lattice_values.get(id);
         else if(curr_node.int_lattice_values.containsKey(id))
         {
            String t = curr_node.int_lattice_values.get(id);
            if(!t.equals("bottom") && !(t.equals("top")))
            {
               if(Integer.parseInt(t) >= 0)
                  id = t;
            }
         }
         if(!do_not_print)
            pw.printf(",%s",id);
      }
   }

   /**
    * f0 -> IntegerLiteral()
    *       | TrueLiteral()
    *       | FalseLiteral()
    *       | Identifier()
    *       | ThisExpression()
    *       | ArrayAllocationExpression()
    *       | AllocationExpression()
    *       | NotExpression()
    */
   public void visit(PrimaryExpression n, A argu) {
      n.f0.accept(this, argu);
      if(n.f0.which == 3)
      {
         String id = tokenName;
         int arg = Integer.valueOf((Integer)argu);
         if(arg == 0)
         {
            curr_node.operation = '=';
            curr_node.id1 = id;
            if(curr_node.int_lattice_values.containsKey(id))
               value_of_expr = curr_node.int_lattice_values.get(id);
            else if(curr_node.bool_lattice_values.containsKey(id))
               value_of_expr = curr_node.bool_lattice_values.get(id);
            else
               value_of_expr = id;
         }
         else
         {
            if(curr_node.int_lattice_values.containsKey(id))
            {
               String t = curr_node.int_lattice_values.get(id);
               if(t.equals("bottom") || t.equals("top"))
                  value_of_expr = id;
               else
               {
                  int x = 0;
                  x = Integer.parseInt(t);
                  if(x >= 0)
                     value_of_expr = t;//we may propagate only non-negative values due to the limitation of the grammar!
                  else
                     value_of_expr = String.format("0 - %d",Math.abs(x));
               }
            }
            else if(curr_node.bool_lattice_values.containsKey(id))
               value_of_expr = (curr_node.bool_lattice_values.get(id).equals("bottom") || curr_node.bool_lattice_values.get(id).equals("top"))?id:curr_node.bool_lattice_values.get(id);
            else
               value_of_expr = id;
            if(!do_not_print)
               pw.printf("%s",value_of_expr);
         }
      }
   }

   /**
    * f0 -> <INTEGER_LITERAL>
    */
   public void visit(IntegerLiteral n, A argu) {
      int arg = Integer.valueOf((Integer)argu);
      n.f0.accept(this, argu);
      value_of_expr = tokenName;
      curr_node.operation = '@';
      curr_node.id1 = value_of_expr;
      if(arg == 1)
      {
         if(!do_not_print)
            pw.printf("%s",value_of_expr);
      }
   }

   /**
    * f0 -> "true"
    */
   public void visit(TrueLiteral n, A argu) {
      int arg = Integer.valueOf((Integer)argu);
      n.f0.accept(this, argu);
      value_of_expr = tokenName;
      curr_node.operation = '@';
      curr_node.id1 = value_of_expr;
      if(arg == 1)
      {
         if(!do_not_print)
            pw.printf("%s",value_of_expr);
      }
   }

   /**
    * f0 -> "false"
    */
   public void visit(FalseLiteral n, A argu) {
      int arg = Integer.valueOf((Integer)argu);
      n.f0.accept(this, argu);
      value_of_expr = tokenName;
      curr_node.operation = '@';
      curr_node.id1 = value_of_expr;
      if(arg == 1)
      {
         if(!do_not_print)
            pw.printf("%s",value_of_expr);
      }
   }

   /**
    * f0 -> <IDENTIFIER>
    */
   public void visit(Identifier n, A argu) {
      n.f0.accept(this, argu);
      value_of_expr = tokenName;
   }

   /**
    * f0 -> "this"
    */
   public void visit(ThisExpression n, A argu) {
      int arg = Integer.valueOf((Integer)argu);
      n.f0.accept(this, argu);
      if(arg == 1)
      {
         if(!do_not_print)
            pw.printf("this");
      }
      value_of_expr = "this";
   }

   /**
    * f0 -> "new"
    * f1 -> "int"
    * f2 -> "["
    * f3 -> Identifier()
    * f4 -> "]"
    */
   public void visit(ArrayAllocationExpression n, A argu) {
      int arg = Integer.valueOf((Integer)argu);
      if(arg == 0)
      {
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
         n.f2.accept(this, argu);
         n.f3.accept(this, argu);
         String id = tokenName;
         n.f4.accept(this, argu);
         value_of_expr = "bottom";
      }
      else
      {
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
         n.f2.accept(this, argu);
         n.f3.accept(this, argu);
         String id = tokenName;
         n.f4.accept(this, argu);
         if(curr_node.int_lattice_values.containsKey(id))
            id = (curr_node.int_lattice_values.get(id).equals("bottom") || curr_node.int_lattice_values.get(id).equals("top"))?id:curr_node.int_lattice_values.get(id);
         value_of_expr = "bottom";
         if(!do_not_print)
            pw.printf("new int[%s]",id);
      }
   }

   /**
    * f0 -> "new"
    * f1 -> Identifier()
    * f2 -> "("
    * f3 -> ")"
    */
   public void visit(AllocationExpression n, A argu) {
      int arg = Integer.valueOf((Integer)argu);
      if(arg == 0)
      {
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
         n.f2.accept(this, argu);
         n.f3.accept(this, argu);
         value_of_expr = "bottom";
      }
      else
      {
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
         String id = tokenName;
         n.f2.accept(this, argu);
         n.f3.accept(this, argu);
         value_of_expr = "bottom";
         if(!do_not_print)
            pw.printf("new %s()",id);
      }
   }

   /**
    * f0 -> "!"
    * f1 -> Identifier()
    */
   public void visit(NotExpression n, A argu) {
      int arg = Integer.valueOf((Integer)argu);
      if(arg == 0)
      {
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
         String id = tokenName;
         curr_node.id1 = id;
         curr_node.operation = '!';
         String t = (curr_node.bool_lattice_values.containsKey(id))?curr_node.bool_lattice_values.get(id):"bottom";
         if(t.equals("bottom"))
            value_of_expr = "bottom";
         else
            value_of_expr = (t.equals("true"))?"false":"true";
      }
      else
      {
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
         String id = tokenName;
         String t = (curr_node.bool_lattice_values.containsKey(id))?curr_node.bool_lattice_values.get(id):"bottom";
         if(t.equals("bottom"))
            value_of_expr = String.format("!%s",id);
         else
            value_of_expr = (t.equals("true"))?"false":"true";
         if(!do_not_print)
            pw.printf("%s",value_of_expr);
      }
   }
}

