//
// Generated by JTB 1.3.2
//
package visitor;
import syntaxtree.*;
import java.util.*;
import java.io.PrintWriter;

/**
 * Provides default methods which visit each node in the tree in depth-first
 * order.  Your visitors may extend this class.
 */
public class MyVisitor<A> implements GJVoidVisitor<A> {
   //
   // Auto class visitors--probably don't need to be overridden.
   //
   Comparator<Pair<Integer,String>> cmp = new Comparator<Pair<Integer,String>>(){
      public int compare(Pair<Integer,String> p1,Pair<Integer,String> p2)
      {
         if(p1.first < p2.first)
            return 1;
         else if(p1.first > p2.first)
            return -1;
         else
         {
            int y = p1.second.compareTo(p2.second);
            if(y < 0)
               return 1;
            else if(y > 0)
               return -1;
            else
               return 0;
         }
      }
   };
   class StackNode
   {
      public ArrayList<StackNode> predecessors;
      public ArrayList<StackNode> successors;
      public Hashtable<String,ArrayList<Integer>> abstract_values;
      public StackNode()
      {
         predecessors = new ArrayList<StackNode>();
         successors = new ArrayList<StackNode>();
         abstract_values = new Hashtable<String,ArrayList<Integer>>();
      }
   }
   class HeapNode
   {
      public ArrayList<HeapNode> predecessors;
      public ArrayList<HeapNode> successors;
      public TreeMap<Pair<Integer,String>,ArrayList<Integer>> abstract_values;
      public HeapNode()
      {
         predecessors = new ArrayList<HeapNode>();
         successors = new ArrayList<HeapNode>();
         abstract_values = new TreeMap<Pair<Integer,String>,ArrayList<Integer>>(cmp);
      }
   }
   class StatementNode
   {
      ArrayList<String> id_list;//list of alll identifiers encountered
      boolean is_assignment;
      char op;//the operation involved,if any.
      boolean inline_req;
      int condition_count1;//how many statements after a conditional block?
      int condition_count2;
      /* 
      p : print statement
      -,+,<,&,*,! : assignment statements (flag would be set to true)
      [ : array access statement
      l : array length
      { : block statement begins 
      } : block statement ends
      w : while statement
      i : if else statement
      v : void message send statement
      r : return message send statement
      a : array allocation expression
      o : object allocation expression
      d : dot expression for assignment
      e : entry basic block
      x : exit basic block
      */
      public StatementNode()
      {
         id_list = new ArrayList<String>();
         is_assignment = false;
         inline_req = false;
         op = '~';
      }
   }
   class FunctionTable
   {
       public Hashtable<String,String> local_variables;
       public LinkedHashMap<String,String> arguments;
       public String return_type;
       public String return_id;
       public ArrayList<StatementNode> function_body;
       public ArrayList<StackNode> stack_values;
       public ArrayList<HeapNode> heap_values;
       public ArrayList<FunctionTable> function_inlined;
       public ArrayList<String> inline_types;
       public int inline_count;
       public Hashtable<String,String> inline_temporaries;//generated as a result of an inline request
       public String caller_obj_type;
       public FunctionTable()
       {
           local_variables = new Hashtable<String,String>();
           arguments = new LinkedHashMap<String,String>();
           local_variables = new Hashtable<String,String>();
           function_body = new ArrayList<StatementNode>();
           return_type = return_id = null;
           function_inlined = new ArrayList<FunctionTable>();
           inline_temporaries = new Hashtable<String,String>();
           inline_count = 0;
           inline_types = new ArrayList<String>();
       } 
   }
   class ClassTable
   {
       public Hashtable<String,String> class_fields;
       public Hashtable<String,FunctionTable> functions;
       public String parent;
       public ClassTable()
       {
           class_fields = new Hashtable<String,String>();
           functions = new Hashtable<String,FunctionTable>();
           parent = null;
       }
   }
   PrintWriter pw = new PrintWriter(System.out,true);
   String tokenName;
   String main_class;
   String type_of_expr;
   String value_of_expr;//no constant propagation so going to be the same as earlier
   StatementNode current_statement;
   String current_class;
   String class_inline;
   String current_function;
   ClassTable class_object;
   FunctionTable function_object;
   Hashtable<String,ClassTable> classes = new Hashtable<String,ClassTable>();
   boolean inline = false;
   int inline_locals = 0;//local variables for inlining purposes
   ArrayList<StackNode> stack_values;
   ArrayList<HeapNode> heap_values;
   StackNode curr_stack_node;
   HeapNode curr_heap_node;
   int stat_counter = 0;
   int inline_stat_counter = 0;//to process inline requests
   int for_counter;
   boolean inline_req = false;
   int object_alloc = 0;//abstract values to be used by the object allocation statements in the program
   Hashtable<Integer,String> object_values = new Hashtable<Integer,String>();//these are the types of each abstract value
   String get_type(String id)
   {
      if(function_object.arguments.containsKey(id))
         return function_object.arguments.get(id);
      else
      {
         if(function_object.local_variables.containsKey(id))
            return function_object.local_variables.get(id);
         else
         {
            String cc = current_class;
            ClassTable co;
            while(cc != null)
            {
               co = classes.get(cc);
               if(co.class_fields.containsKey(id))
                  return co.class_fields.get(id);
               cc = co.parent;
            }
            return null;
         }
      }
   }
   String get_type(String class_type,String id)
   {
      if(id.equals("this"))
         return class_type;
      String cc = class_type;
      while(cc != null)
      {
         ClassTable c1 = classes.get(cc);
         if(c1.class_fields.containsKey(id))
            return c1.class_fields.get(id);
         cc = c1.parent;
      }
      return null;
   }

   FunctionTable get_function_object(String ty,String fn_name)
   {
      String ty1=  ty;
      while(ty1 != null)
      {
         ClassTable ct = classes.get(ty1);
         if(ct.functions.containsKey(fn_name))
         {
            class_inline = ty1;
            return ct.functions.get(fn_name);
         }
         ty1 = ct.parent;
      }
      return null;
   }
   
   String get_format_string(String id,FunctionTable ft,int inline_count)
   {
      String s;
      if(ft.arguments.containsKey(id) || ft.local_variables.containsKey(id))
         s = String.format("__inline%d_%s",inline_count,id);
      else
         s = String.format("__inline%d_class_%s",inline_count,id);
      return s;
   }
   void prepare_function_code(FunctionTable obj)
   {
      int i = 0;
      for(StatementNode stat: obj.function_body)
      {
         StackNode s = obj.stack_values.get(i);
         HeapNode h = obj.heap_values.get(i);
         i++;
         char o = stat.op;
         String cl = "x";
         String fn = "x";
         if(o == 'r')
         {
            cl = stat.id_list.get(1);
            fn = stat.id_list.get(2);
         }
         else if(o == 'v')
         {  
            cl = stat.id_list.get(0);
            fn = stat.id_list.get(1);
         } 
         
         if(stat.inline_req)//can be set to true only upon r or v
         {
            //see if we can inline now.
            ArrayList<Integer> a;
            try
            {
               int x = Integer.parseInt(cl);
               a = new ArrayList<Integer>();
               a.add(x);
            }
            catch(NumberFormatException e)
            {
               if(s.abstract_values.containsKey(cl))
               {
                  a = s.abstract_values.get(cl);
               }
               else
               {
                  a = new ArrayList<Integer>();
                  //heap by this pointer
                  Pair<Integer,String> p1 = new Pair<Integer,String>(1,cl);
                  for(Integer z: s.abstract_values.get("this"))
                  {
                     p1.first = z;
                     for(Integer z1: h.abstract_values.get(p1))
                     {
                        if(!a.contains(z1))
                           a.add(z1);
                     }
                  }
               }
            }   
            Hashtable<FunctionTable,Boolean> f_v = new Hashtable<FunctionTable,Boolean>();
            Hashtable<String,Boolean> f_c = new Hashtable<String,Boolean>();
            for(Integer z: a)
            {
               FunctionTable fg = get_function_object(object_values.get(z),fn);
               if(fg == null)
                  continue;
               f_v.put(fg,true);
               f_c.put(class_inline,true);
            }
            
            if(f_v.size() == 1)
            {
               //now we know which object to inline!
               FunctionTable il = f_v.keySet().iterator().next();
               String class_il = f_c.keySet().iterator().next();
               obj.function_inlined.add(il);
               obj.inline_types.add(class_il);
               for(Map.Entry<String,String> m: il.arguments.entrySet())
               {
                  String id = m.getKey();
                  String ty = m.getValue();
                  obj.inline_temporaries.put(String.format("__inline%d_%s",obj.inline_count,id),ty);
               }
               for(Map.Entry<String,String> m: il.local_variables.entrySet())
               {
                  String id = m.getKey();
                  String ty = m.getValue();
                  obj.inline_temporaries.put(String.format("__inline%d_%s",obj.inline_count,id),ty);
               }
               Hashtable<String,Boolean> ht = new Hashtable<String,Boolean>();
               while(class_il != null)
               {
                  ClassTable co = classes.get(class_il);
                  for(Map.Entry<String,String> m: co.class_fields.entrySet())
                  {
                     String id = m.getKey();
                     String ty = m.getValue();
                     if(ht.containsKey(id))
                        continue;
                     ht.put(id,true);
                     obj.inline_temporaries.put(String.format("__inline%d_class_%s",obj.inline_count,id),ty);
                  }
                  class_il = co.parent;
               }
               obj.inline_count++;
            }
            else
            {
               stat.inline_req = false;//cannot be inlined
            }
         }
      }
   }
   
   void process_inline_statement(StatementNode stat,FunctionTable ft,int inline_count)
   {
      char o = stat.op;
      if(stat.is_assignment)
      {
         if(o == '=')//= is an assignment statement
         {
            String id1 = get_format_string(stat.id_list.get(0), ft, inline_count);
            String id2 = get_format_string(stat.id_list.get(1), ft, inline_count);
            pw.printf("%s = %s;\n",id1,id2);
         }
         else if(o == '~')
         {
            String id1 = get_format_string(stat.id_list.get(0), ft, inline_count);
            String id2 = stat.id_list.get(1);//this is a constant or the this pointer,check?
            if(id2.equals("this"))
            {
               id2 = get_format_string(id2, ft, inline_count);
            }
            pw.printf("%s = %s;\n",id1,id2);
         }
         else if(o == 'z')
         {
            String id = get_format_string(stat.id_list.get(0), ft, inline_count);
            String v =  get_format_string(stat.id_list.get(1), ft, inline_count);
            pw.printf("%s = new int[%s];\n",id,v);
         }
         else if(o == 'o')
         {
            String id = get_format_string(stat.id_list.get(0), ft, inline_count);
            int v1 = Integer.parseInt(stat.id_list.get(1));
            String v = object_values.get(v1);
            pw.printf("%s = new %s();\n",id,v);
         }
         else if(o == 'd')
         {
            String id = get_format_string(stat.id_list.get(0), ft, inline_count);
            String ob = get_format_string(stat.id_list.get(1), ft, inline_count);
            String f = stat.id_list.get(2);
            pw.printf("%s = %s.%s;\n",id,ob,f);
         }
         else if(o == '-' || o == '+' || o == '*' || o == '<' || o == '&')
         {
            String id1 = get_format_string(stat.id_list.get(0), ft, inline_count);
            String id2 = get_format_string(stat.id_list.get(1), ft, inline_count);
            String id3 = get_format_string(stat.id_list.get(2), ft, inline_count);
            pw.printf("%s = %s %c %s;\n",id1,id2,o,id3);
         }
         else if(o == '!')
         {
            String id1 = get_format_string(stat.id_list.get(0), ft, inline_count);
            String id2 = get_format_string(stat.id_list.get(1), ft, inline_count);
            pw.printf("%s = !%s;\n",id1,id2);
         }
         else if(o == 'l')
         {
            String id1 = get_format_string(stat.id_list.get(0), ft, inline_count);
            String id2 = get_format_string(stat.id_list.get(1), ft, inline_count);
            pw.printf("%s = %s.length;\n",id1,id2);
         }
         else if(o == '[')
         {
            String id1 = get_format_string(stat.id_list.get(0), ft, inline_count);
            String id2 = get_format_string(stat.id_list.get(1), ft, inline_count);
            String id3 = get_format_string(stat.id_list.get(2), ft, inline_count);
            pw.printf("%s = %s[%s];\n",id1,id2,id3);
         }
         else if(o == 'a')
         {
            String id1 = get_format_string(stat.id_list.get(0), ft, inline_count);
            String id2 = get_format_string(stat.id_list.get(1), ft, inline_count);
            String id3 = get_format_string(stat.id_list.get(2), ft, inline_count);
            pw.printf("%s[%s] = %s;\n",id1,id2,id3);
         }
         else if(o == 'f')
         {
            String id1 = get_format_string(stat.id_list.get(0), ft, inline_count);
            String id2 = stat.id_list.get(1);
            String id3 = get_format_string(stat.id_list.get(2), ft, inline_count);
            String z = get_type(ft.caller_obj_type,id2);
            if(z != null)
               pw.printf("__inline%d_this.%s = __inline%d_class_%s;\n",inline_count,id2,inline_count,id2);
            pw.printf("%s.%s = %s;\n",id1,id2,id3);
            if(z != null)
               pw.printf("__inline%d_class_%s = __inline%d_this.%s;\n",inline_count,id2,inline_count,id2);
            
         }
         else if(o == 'r')
         {
            String id1 = get_format_string(stat.id_list.get(0), ft, inline_count);
            String id2 = stat.id_list.get(1);
            String id3 = stat.id_list.get(2);
            try
            {
               int x = Integer.parseInt(id2);
               id2 = String.format("new %s()",object_values.get(x));
            }
            catch(NumberFormatException e){
               id2 = get_format_string(id2, ft, inline_count);
            }
            String c1 = ft.caller_obj_type;
            Hashtable<String,Boolean> ht = new Hashtable<String,Boolean>();
            while(c1 != null)
            {
               ClassTable ct = classes.get(c1);
               for(Map.Entry<String,String> m: ct.class_fields.entrySet())
               {
                  String id = m.getKey();
                  if(ht.containsKey(id))
                     continue;
                  ht.put(id,true);
                  pw.printf("__inline%d_this.%s = __inline%d_class_%s;\n",inline_count,id,inline_count,id);
               }
               c1 = ct.parent;
            }
            pw.printf("%s = %s.%s(",id1,id2,id3);
            boolean pr = false;
            int i;
            int n = stat.id_list.size();
            for(i = 3;i < n;i++)
            {
               String id = get_format_string(stat.id_list.get(i), ft, inline_count);
               if(pr)
                  pw.printf(",%s",id);
               else
                  pw.printf("%s",id);
               pr = true;
            }
            pw.printf(");\n");
            //restoring heap values is important
            c1 = ft.caller_obj_type;
            ht = new Hashtable<String,Boolean>();
            while(c1 != null)
            {
               ClassTable ct = classes.get(c1);
               for(Map.Entry<String,String> m: ct.class_fields.entrySet())
               {
                  String id = m.getKey();
                  if(ht.containsKey(id))
                     continue;
                  ht.put(id,true);
                  if(id1.equals(get_format_string(id, ft, inline_count)))
                     continue;//this is actually a return value so chill
                  pw.printf("__inline%d_class_%s = __inline%d_this.%s;\n",inline_count,id,inline_count,id);
               }
               c1 = ct.parent;
            }
         }
         else
         {

         }
         inline_stat_counter++;//move this pointer to allow dispatch.We have ignored entry,exit and join blocks as they mean nothing
      }
      else
      {
         if(o == 'p')
         {
            String pi = get_format_string(stat.id_list.get(0), ft, inline_count);
            pw.printf("System.out.println(%s);\n",pi);
            inline_stat_counter++;
         }
         else if(o == 'v')
         {
            String id2 = stat.id_list.get(0);
            String id3 = stat.id_list.get(1);
            try
            {
               int x = Integer.parseInt(id2);
               id2 = String.format("new %s()",object_values.get(x));
            }
            catch(NumberFormatException e){
               id2 = get_format_string(id2, ft, inline_count);
            }
            //restoring heap values is important
            String c1 = ft.caller_obj_type;
            Hashtable<String,Boolean> ht = new Hashtable<String,Boolean>();
            while(c1 != null)
            {
               ClassTable ct = classes.get(c1);
               for(Map.Entry<String,String> m: ct.class_fields.entrySet())
               {
                  String id = m.getKey();
                  if(ht.containsKey(id))
                     continue;
                  ht.put(id,true);
                  pw.printf("__inline%d_this.%s = __inline%d_class_%s;\n",inline_count,id,inline_count,id);
               }
               c1 = ct.parent;
            }
            pw.printf("%s.%s(",id2,id3);
            boolean pr = false;
            int i;
            int n = stat.id_list.size();
            for(i = 2;i < n;i++)
            {
               String id = get_format_string(stat.id_list.get(i), ft, inline_count);
               if(pr)
                  pw.printf(",%s",id);
               else
                  pw.printf("%s",id);
               pr = true;
            }
            pw.printf(");\n");
            //restoring heap values is important
            c1 = ft.caller_obj_type;
            ht = new Hashtable<String,Boolean>();
            while(c1 != null)
            {
               ClassTable ct = classes.get(c1);
               for(Map.Entry<String,String> m: ct.class_fields.entrySet())
               {
                  String id = m.getKey();
                  if(ht.containsKey(id))
                     continue;
                  ht.put(id,true);
                  pw.printf("__inline%d_class_%s = __inline%d_this.%s;\n",inline_count,id,inline_count,id);
               }
               c1 = ct.parent;
            }
            inline_stat_counter++;
         }
         else if(o == 'w')
         {
            //while loop
            String id = get_format_string(stat.id_list.get(0), ft, inline_count);
            int i;
            pw.printf("while(%s){\n",id);
            inline_stat_counter++;
            int ub = inline_stat_counter + stat.condition_count1;
            while(inline_stat_counter < ub)
            {
               StatementNode c1 = ft.function_body.get(inline_stat_counter);
               process_inline_statement(c1, ft,inline_count);
            }
            pw.printf("}\n");
         }
         else if(o == 'i')
         {
            String id = get_format_string(stat.id_list.get(0), ft, inline_count);
            pw.printf("if(%s){\n",id);
            inline_stat_counter++;
            int ub = inline_stat_counter + stat.condition_count1;
            while(inline_stat_counter < ub)
            {
               StatementNode c1 = ft.function_body.get(inline_stat_counter);
               process_inline_statement(c1, ft,inline_count);
            }
            pw.print("}\nelse{\n");
            ub = inline_stat_counter + stat.condition_count2;
            while(inline_stat_counter < ub)
            {
               StatementNode c1 = ft.function_body.get(inline_stat_counter);
               process_inline_statement(c1, ft,inline_count);
            }
            pw.print("}\n");
         }
         else
         {
            inline_stat_counter++;
         }
      }
   }

   void process_statement(StatementNode stat,FunctionTable ft)
   {
      char o = stat.op;
      if(stat.is_assignment)
      {
         if(o == '=' || o == '~')//~ is an assignment statement used for constants
         {
            String id1 = stat.id_list.get(0);
            String id2 = stat.id_list.get(1);
            pw.printf("%s = %s;\n",id1,id2);
         }
         else if(o == 'z')
         {
            String id = stat.id_list.get(0);
            String v = stat.id_list.get(1);
            pw.printf("%s = new int[%s];\n",id,v);
         }
         else if(o == 'o')
         {
            String id = stat.id_list.get(0);
            int v1 = Integer.parseInt(stat.id_list.get(1));
            String v = object_values.get(v1);
            pw.printf("%s = new %s();\n",id,v);
         }
         else if(o == 'd')
         {
            String id = stat.id_list.get(0);
            String ob = stat.id_list.get(1);
            String f = stat.id_list.get(2);
            pw.printf("%s = %s.%s;\n",id,ob,f);
         }
         else if(o == '-' || o == '+' || o == '*' || o == '<' || o == '&')
         {
            String id1 = stat.id_list.get(0);
            String id2 = stat.id_list.get(1);
            String id3 = stat.id_list.get(2);
            pw.printf("%s = %s %c %s;\n",id1,id2,o,id3);
         }
         else if(o == '!')
         {
            String id1 = stat.id_list.get(0);
            String id2 = stat.id_list.get(1);
            pw.printf("%s = !%s;\n",id1,id2);
         }
         else if(o == 'l')
         {
            String id1 = stat.id_list.get(0);
            String id2 = stat.id_list.get(1);
            pw.printf("%s = %s.length;\n",id1,id2);
         }
         else if(o == '[')
         {
            String id1 = stat.id_list.get(0);
            String id2 = stat.id_list.get(1);
            String id3 = stat.id_list.get(2);
            pw.printf("%s = %s[%s];\n",id1,id2,id3);
         }
         else if(o == 'a')
         {
            String id1 = stat.id_list.get(0);
            String id2 = stat.id_list.get(1);
            String id3 = stat.id_list.get(2);
            pw.printf("%s[%s] = %s;\n",id1,id2,id3);
         }
         else if(o == 'f')
         {
            String id1 = stat.id_list.get(0);
            String id2 = stat.id_list.get(1);
            String id3 = stat.id_list.get(2);
            pw.printf("%s.%s = %s;\n",id1,id2,id3);
         }
         else if(o == 'r')
         {
            String id1 = stat.id_list.get(0);
            String id2 = stat.id_list.get(1);//may be new keyword
            String id3 = stat.id_list.get(2);
            if(!stat.inline_req)
            {
               try
               {
                  int x = Integer.parseInt(id2);
                  id2 = String.format("new %s()",object_values.get(x));
               }
               catch(NumberFormatException e){}
               pw.printf("%s = %s.%s(",id1,id2,id3);
               boolean pr = false;
               int i;
               int n = stat.id_list.size();
               for(i = 3;i < n;i++)
               {
                  String id = stat.id_list.get(i);
                  if(pr)
                     pw.printf(",%s",id);
                  else
                     pw.printf("%s",id);
                  pr = true;
               }
               pw.printf(");\n");
            }
            else
            {
               //set up arguments in the epilogue, and then subsequently 
               FunctionTable fo = ft.function_inlined.get(ft.inline_count);
               String ob_t = ft.inline_types.get(ft.inline_count);
               int z = ft.inline_count;
               ft.inline_count = z+1;
               inline_stat_counter = 0;//set the arguments before passing alone!
               int i = 3;
               for(Map.Entry<String,String> m:fo.arguments.entrySet())
               {
                  String id = m.getKey();
                  if(id.equals("this"))
                  {
                     try
                     {
                        int x = Integer.parseInt(id2);
                        id2 = String.format("new %s()",object_values.get(x));
                     }
                     catch(NumberFormatException e){}
                     pw.printf("__inline%d_this = %s;\n",z,id2);
                  }
                  else
                  {
                     String id_v = stat.id_list.get(i);
                     i++;
                     pw.printf("__inline%d_%s = %s;\n",z,id,id_v);
                  }
               }
               String d = ob_t;
               Hashtable<String,Boolean> ht = new Hashtable<String,Boolean>();
               while(d != null)
               {
                  ClassTable ct1 = classes.get(d);
                  for(Map.Entry<String,String> m: ct1.class_fields.entrySet())
                  {
                     String id = m.getKey();
                     if(ht.containsKey(id))
                        continue;
                     ht.put(id,true);
                     pw.printf("__inline%d_class_%s = __inline%d_this.%s;\n",z,id,z,id);
                  }
                  d = ct1.parent;
               }
               int maxi = fo.function_body.size();
               fo.caller_obj_type = ob_t;
               while(inline_stat_counter < maxi)
               {
                  StatementNode sta = fo.function_body.get(inline_stat_counter);
                  process_inline_statement(sta,fo,z);
               }
               d = ob_t;
               ht = new Hashtable<String,Boolean>();
               while(d != null)
               {
                  ClassTable ct1 = classes.get(d);
                  for(Map.Entry<String,String> m: ct1.class_fields.entrySet())
                  {
                     String id = m.getKey();
                     if(ht.containsKey(id))
                        continue;
                     ht.put(id,true);
                     pw.printf("__inline%d_this.%s = __inline%d_class_%s;\n",z,id,z,id);
                  }
                  d = ct1.parent;
               }
               pw.printf("%s = %s;\n",id1,get_format_string(fo.return_id,fo,z));//inlining is over
            }
         }
         stat_counter++;//move this pointer to allow dispatch.We have ignored entry,exit and join blocks as they mean nothing
         
      }
      else
      {
         if(o == 'p')
         {
            String pi = stat.id_list.get(0);
            pw.printf("System.out.println(%s);\n",pi);
            stat_counter++;
         }
         else if(o == 'v')
         {
            String id2 = stat.id_list.get(0);
            String id3 = stat.id_list.get(1);
            try
            {
               int x = Integer.parseInt(id2);
               id2 = String.format("new %s()",object_values.get(x));
            }
            catch(NumberFormatException e){}
            if(!stat.inline_req)
            {
               pw.printf("%s.%s(",id2,id3);
               boolean pr = false;
               int i;
               int n = stat.id_list.size();
               for(i = 2;i < n;i++)
               {
                  String id = stat.id_list.get(i);
                  if(pr)
                     pw.printf(",%s",id);
                  else
                     pw.printf("%s",id);
                  pr = true;
               }
               pw.printf(");\n");
            }
            else
            {
               FunctionTable fo = ft.function_inlined.get(ft.inline_count);
               String ob_t = ft.inline_types.get(ft.inline_count);
               int z = ft.inline_count;
               ft.inline_count = z+1;
               inline_stat_counter = 0;//set the arguments before passing alone!
               int i = 2;
               for(Map.Entry<String,String> m:fo.arguments.entrySet())
               {
                  String id = m.getKey();
                  if(id.equals("this"))
                  {
                     pw.printf("__inline%d_this = %s;\n",z,id2);
                  }
                  else
                  {
                     String id_v = stat.id_list.get(i);
                     i++;
                     pw.printf("__inline%d_%s = %s;\n",z,id,id_v);
                  }
               }
               fo.caller_obj_type = ob_t;
               int maxi = fo.function_body.size();
               while(inline_stat_counter < maxi)
               {
                  StatementNode sta = fo.function_body.get(inline_stat_counter);
                  process_inline_statement(sta,fo,z);
               }
               String d = ob_t;
               Hashtable<String,Boolean> ht = new Hashtable<String,Boolean>();
               while(d != null)
               {
                  ClassTable ct1 = classes.get(d);
                  for(Map.Entry<String,String> m: ct1.class_fields.entrySet())
                  {
                     String id = m.getKey();
                     if(ht.containsKey(id))
                        continue;
                     ht.put(id,true);
                     pw.printf("__inline%d_this.%s = __inline%d_%s;\n",z,id,z,id);
                  }
                  d = ct1.parent;
               }//inlining is done over here.
            }
            stat_counter++;
         }
         else if(o == 'w')
         {
            //while loop
            String id = stat.id_list.get(0);
            int i;
            pw.printf("while(%s){\n",id);
            stat_counter++;
            int ub = stat_counter + stat.condition_count1;
            while(stat_counter < ub)
            {
               StatementNode c1 = ft.function_body.get(stat_counter);
               process_statement(c1, ft);
            }
            pw.printf("}\n");
         }
         else if(o == 'i')
         {
            String id = stat.id_list.get(0);
            pw.printf("if(%s){\n",id);
            stat_counter++;
            int ub = stat_counter + stat.condition_count1;
            while(stat_counter < ub)
            {
               StatementNode c1 = ft.function_body.get(stat_counter);
               process_statement(c1, ft);
            }
            pw.print("}\nelse{\n");
            ub = stat_counter + stat.condition_count2;
            while(stat_counter < ub)
            {
               StatementNode c1 = ft.function_body.get(stat_counter);
               process_statement(c1, ft);
            }
            pw.print("}\n");
         }
         else
         {
            stat_counter++;
         }
      }
   }
   void print_code(String class_name, String f_name,FunctionTable ft)
   {
      if((class_name.equals(main_class)))
         pw.printf("public static void main(");
      else
         pw.printf("public %s %s(",ft.return_type,f_name);
      boolean pr = false;
      for(Map.Entry<String,String> ar: ft.arguments.entrySet())
      {
         String id = ar.getKey();
         String ty = ar.getValue();
         if(!id.equals("this"))
         {
            if(pr)
               pw.printf(",");
            pw.printf("%s %s",ty,id);
            pr = true;
         }
      }
      pw.println("){\n");
      int n = ft.function_body.size();
      stat_counter = 0;
      for(Map.Entry<String,String> m : ft.local_variables.entrySet())
      {
         pw.printf("%s %s;\n",m.getValue(),m.getKey());
      }
      for(Map.Entry<String,String> m : ft.inline_temporaries.entrySet())
      {
         pw.printf("%s %s;\n",m.getValue(),m.getKey());
      }
      while(stat_counter < n)
      {
         StatementNode st_s = ft.function_body.get(stat_counter);
         process_statement(st_s, ft);
      }
      if(!ft.return_type.equals("void"))
      {
         pw.printf("return %s;\n",ft.return_id);
      }
      pw.printf("}");
   }

   void generate_code()
   {
      ClassTable cl_obj;
      FunctionTable fn_obj;
      for(Map.Entry<String,ClassTable> m: classes.entrySet())
      {
         String class_name = m.getKey();
         cl_obj = m.getValue();
         for(Map.Entry<String,FunctionTable> m1 : cl_obj.functions.entrySet())
         {
            String fn_name = m1.getKey();
            fn_obj = m1.getValue();
            prepare_function_code(fn_obj);
         }
      }
      cl_obj = classes.get(main_class);
      fn_obj = cl_obj.functions.get("main");
      fn_obj.inline_count = 0;
      pw.printf("class %s",main_class);
      if(cl_obj.parent != null)
         pw.printf(" extends %s",cl_obj.parent);
      pw.printf("{\n");
      print_code(main_class,"main",fn_obj);
      pw.println("}\n");
      for(Map.Entry<String,ClassTable> m: classes.entrySet())
      {
         String cl_n = m.getKey();
         if(cl_n.equals(main_class))
            continue;
         cl_obj = m.getValue();
         pw.printf("class %s",cl_n);
         if(cl_obj.parent!=null)
            pw.printf(" extends %s",cl_obj.parent);
         pw.printf("{\n");
         for(Map.Entry<String,String> m1: cl_obj.class_fields.entrySet())
         {
            pw.printf("%s %s;\n",m1.getValue(),m1.getKey());
         }
         for(Map.Entry<String,FunctionTable> m1: cl_obj.functions.entrySet())
         {
            String fn_n = m1.getKey();
            fn_obj = m1.getValue();
            fn_obj.inline_count = 0;
            print_code(cl_n,fn_n,fn_obj);
         }
         pw.printf("}\n");
      }
      //done!
   }


   Hashtable<String,ArrayList<Integer>> stack_meet(Hashtable<String,ArrayList<Integer>> a,Hashtable<String,ArrayList<Integer>> b)
   {
      if(a == null)
         return b;//is guaranteed to be non-null
      Hashtable<String,ArrayList<Integer>> c = new Hashtable<String,ArrayList<Integer>>();
      Iterator<String> it = a.keySet().iterator();
      while(it.hasNext())
      {
         String x = it.next();
         ArrayList<Integer> y = new ArrayList<Integer>();
         ArrayList<Integer> y1 = a.get(x);
         for(Integer z : y1)
            y.add(z);
         c.put(x,y);
      }
      it = b.keySet().iterator();
      while(it.hasNext())
      {
         String x = it.next();
         ArrayList<Integer> y = b.get(x);
         ArrayList<Integer> y1 = c.get(x);
         if(y1 == null)
            y1 = new ArrayList<Integer>();
         for(Integer z: y)
         {
            if(!y1.contains(z))
               y1.add(z);
         }
         c.put(x,y1);
      }
      return c;
   }

   TreeMap<Pair<Integer,String>,ArrayList<Integer>> heap_meet(TreeMap<Pair<Integer,String>,ArrayList<Integer>> a,TreeMap<Pair<Integer,String>,ArrayList<Integer>> b)
   {
      if(a == null)
         return b;
      TreeMap<Pair<Integer,String>,ArrayList<Integer>> c = new TreeMap<Pair<Integer,String>,ArrayList<Integer>>(cmp);
      for(Map.Entry<Pair<Integer,String>,ArrayList<Integer>> e : a.entrySet())
      {
         Pair<Integer,String> a1 = e.getKey();
         ArrayList<Integer> a2 = e.getValue();
         Pair<Integer,String> p2 = new Pair<Integer,String>(a1.first,a1.second);
         ArrayList<Integer> a3 = new ArrayList<Integer>();
         for(Integer z: a2)
            a3.add(z);
         c.put(p2,a3);
      }
      for(Map.Entry<Pair<Integer,String>,ArrayList<Integer>> e : b.entrySet())
      {
         Pair<Integer,String> a1 = e.getKey();
         ArrayList<Integer> a2 = e.getValue();
         ArrayList<Integer> a3 = c.get(a1);
         if(a3 == null)
            a3 = new ArrayList<Integer>();
         for(Integer z: a2)
         {
            if(!a3.contains(z))
               a3.add(z);
         }
         c.put(a1,a3);
      }
      return c;
   }
   
   boolean is_subtype(String a,String b)//is a a sub-type of b?
   {
      ClassTable t;
      while(a != null)
      {  
         if(!a.equals(b))
         {
            t = classes.get(a);
            a = t.parent;
         }
         else
            return true;
      }
      return false;
   }
   Hashtable<String,ArrayList<Integer>> deep_stack_copy(Hashtable<String,ArrayList<Integer>> a)
   {
      Hashtable<String,ArrayList<Integer>> h1 = new Hashtable<String,ArrayList<Integer>>();
      for(Map.Entry<String,ArrayList<Integer>> m: a.entrySet())
      {
         String a11 = m.getKey();
         ArrayList<Integer> a2 = m.getValue();
         ArrayList<Integer> a3 = new ArrayList<Integer>();
         for(Integer z: a2)
            a3.add(z);
         h1.put(a11,a3);
      }
      return h1;
   }

   TreeMap<Pair<Integer,String>,ArrayList<Integer>> deep_heap_copy(TreeMap<Pair<Integer,String>,ArrayList<Integer>> a)
   {
      TreeMap<Pair<Integer,String>,ArrayList<Integer>> c = new TreeMap<Pair<Integer,String>,ArrayList<Integer>>(cmp);
      for(Map.Entry<Pair<Integer,String>,ArrayList<Integer>> m: a.entrySet())
      {
         Pair<Integer,String> p1 = m.getKey();
         ArrayList<Integer> p2 = m.getValue();
         Pair<Integer,String> p11 = new Pair<Integer,String>(p1.first,p1.second);
         ArrayList<Integer> p22 = new ArrayList<Integer>();
         for(Integer z: p2)
            p22.add(z);
         c.put(p11,p22);   
      }
      return c;
   }

   boolean stack_equal(Hashtable<String,ArrayList<Integer>> h1,Hashtable<String,ArrayList<Integer>> h2)
   {
      if(h2==null)
         return false;
      if(h1.size() != h2.size())
         return false;
      for(Map.Entry<String,ArrayList<Integer>> m: h1.entrySet())
      {
         if(!h2.containsKey(m.getKey()))
            return false;
         ArrayList<Integer> a1 = h2.get(m.getKey());
         if(a1 == null)
            return false;
         ArrayList<Integer> a2 = m.getValue();
         for(Integer z: a2)
         {
            if(!a1.contains(z))
               return false;
         }
         if(a1.size() != a2.size())
            return false;
      }
      return true;
   }

   boolean heap_equal(TreeMap<Pair<Integer,String>,ArrayList<Integer>> h1,TreeMap<Pair<Integer,String>,ArrayList<Integer>> h2)
   {
      if(h2==null)
         return false;
      if(h1.size() != h2.size())
         return false;
      for(Map.Entry<Pair<Integer,String>,ArrayList<Integer>> m: h1.entrySet())
      {
         if(!h2.containsKey(m.getKey()))
            return false;
         ArrayList<Integer> a1 = h2.get(m.getKey());
         if(a1 == null)
            return false;
         ArrayList<Integer> a2 = m.getValue();
         for(Integer z: a2)
         {
            if(!a1.contains(z))
               return false;
         }
         if(a1.size() != a2.size())
            return false;
      }
      return true;
   }
   void conditional_prop()
   {
      //run the analysis until iterative convergence.
      int n = function_object.function_body.size();//total number of BBs
      int i;
      boolean change;
      int cnt = 0;
      curr_stack_node = function_object.stack_values.get(0);
      curr_heap_node = function_object.heap_values.get(0);
      current_statement = function_object.function_body.get(0);
      int j;
      for(j = 0;j < object_alloc;j++)
      {
         String ty = object_values.get(j);
         while(ty != null)
         {
            ClassTable cl_obj = classes.get(ty);
            Hashtable<String,Boolean> pr = new Hashtable<String,Boolean>();
            for(Map.Entry<String,String> m : cl_obj.class_fields.entrySet())
            {
               if(pr.containsKey(m.getKey()))
                  continue;
               pr.put(m.getKey(),true);
               String k = m.getValue();
               if(classes.containsKey(k))
               {
                  Pair<Integer,String> x = new Pair<Integer,String>(j,m.getKey());
                  ArrayList<Integer> ar = new ArrayList<Integer>();
                  int k1;
                  for(k1 = 0;k1 < object_alloc;k1++)
                  {
                     String ty1 = object_values.get(k1);
                     if(is_subtype(ty1,k))
                        ar.add(k1);
                  }
                  curr_heap_node.abstract_values.put(x,ar);
               }
            }
            ty = cl_obj.parent;
         }
      }
      for(Map.Entry<String,String> e: function_object.arguments.entrySet())
      {
         String k = e.getKey();
         String v = e.getValue();
         if(classes.containsKey(v))
         {
            int k1;
            ArrayList<Integer> ar = new ArrayList<Integer>();//entry basic block
            for(k1 = 0;k1 < object_alloc;k1++)
            {
               String ty = object_values.get(k1);
               if(is_subtype(ty, v))
                  ar.add(k1);
            }
            curr_stack_node.abstract_values.put(k,ar);
         }
      }
      for(Map.Entry<String,String> e:function_object.local_variables.entrySet())
      {
         String k = e.getKey();
         String v = e.getValue();
         if(classes.containsKey(v))
         {
            ArrayList<Integer> ar = new ArrayList<Integer>();
            curr_stack_node.abstract_values.put(k,ar);
         }
      }
      do
      {
         change = false;
         for(i = 1;i < n;i++)
         {
            curr_stack_node = function_object.stack_values.get(i);
            curr_heap_node = function_object.heap_values.get(i);
            current_statement = function_object.function_body.get(i);
            char o = current_statement.op;
            if(o == 'e')
            {
               continue;//won't happen but anyway
            }
            else
            {
               //not the entry basic block. Take meet of predecessors etc.
               Hashtable<String,ArrayList<Integer>> h = null;
               TreeMap<Pair<Integer,String>,ArrayList<Integer>> t = null;
               //pw.printf("%c %b\n",current_statement.op,current_statement.is_assignment);
               for(StackNode st: curr_stack_node.predecessors)
               {
                  StatementNode stat = function_object.function_body.get(function_object.stack_values.indexOf(st));//corresponding statement
                  Hashtable<String,ArrayList<Integer>> h1 = deep_stack_copy(st.abstract_values);
                  HeapNode hn = function_object.heap_values.get(function_object.stack_values.indexOf(st));
                  TreeMap<Pair<Integer,String>,ArrayList<Integer>> t1 = deep_heap_copy(hn.abstract_values);
                  
                  if(stat.is_assignment)
                  {
                     if(stat.op == '[')
                     {
                        h = stack_meet(h,h1);
                        continue;
                     }
                     String x1 = stat.id_list.get(0);
                     if(!classes.containsKey(get_type(x1)))
                     {
                        h = stack_meet(h, h1);
                        continue;
                     }
                     if(!((function_object.local_variables.containsKey(x1)) || (function_object.arguments.containsKey(x1))))
                     {
                        h = stack_meet(h, h1);//no change to h1 over here!
                        //this is now a heap write operation because of the this pointer! Be careful!
                        if(stat.op == '=')
                        {
                           String x2 = stat.id_list.get(1);
                           //outflow changes now. Simply update the lattice
                           ArrayList<Integer> a = new ArrayList<Integer>();
                           if(st.abstract_values.containsKey(x2))
                           {
                              for(Integer z: st.abstract_values.get(x2))
                                 a.add(z);
                           }
                           else
                           {
                              Pair<Integer,String> pa = new Pair<Integer,String>(1,x2);
                              for(Integer z: st.abstract_values.get("this"))
                              {
                                 pa.first = z;
                                 for(Integer z1: hn.abstract_values.get(pa))
                                 {
                                    if(!a.contains(z1))
                                       a.add(z1);
                                 }
                              }
                           }
                     
                           ArrayList<Integer> av = st.abstract_values.get("this");
                           if(av.size() == 1)
                           {
                              //strict update
                              t1.put(new Pair<Integer,String>(av.get(0),x1),a);
                           }
                           else
                           {
                              Pair<Integer,String> p1 = new Pair<Integer,String>(1,x1);
                              for(Integer z: av)
                              {
                                 p1.first = z;
                                 ArrayList<Integer> a2 = new ArrayList<Integer>();
                                 for(Integer z1: a)
                                    a2.add(z1);
                                 ArrayList<Integer> a3 = hn.abstract_values.get(p1);
                                 for(Integer z1: a3)
                                 {
                                    if(!a2.contains(z1))
                                       a2.add(z1);
                                 }
                                 t1.put(p1,a2);//weakly update the heap values for a write operation.
                              }
                           }
                           t = heap_meet(t,t1);
                        }
                        else if(stat.op == 'o')
                        {
                           int s = Integer.parseInt(stat.id_list.get(1));
                           ArrayList<Integer> a = new ArrayList<Integer>();
                           a.add(s);
                           ArrayList<Integer> av = st.abstract_values.get("this");
                           if(av.size() == 1)
                           {
                              //strict update
                              t1.put(new Pair<Integer,String>(av.get(0),x1),a);
                           }
                           else
                           {
                              Pair<Integer,String> p1 = new Pair<Integer,String>(1,x1);
                              for(Integer z: av)
                              {
                                 p1.first = z;
                                 ArrayList<Integer> a2 = new ArrayList<Integer>();
                                 for(Integer z1: a)
                                    a2.add(z1);
                                 ArrayList<Integer> a3 = hn.abstract_values.get(p1);
                                 for(Integer z1: a3)
                                 {
                                    if(!a2.contains(z1))
                                       a2.add(z1);
                                 }
                                 t1.put(p1,a2);//weakly update the heap values for a write operation.
                              }
                           }
                           t = heap_meet(t,t1);
                        }
                        else if(stat.op == 'd')
                        {
                           String x2 = stat.id_list.get(1);
                           String x3 = stat.id_list.get(2);
                           ArrayList<Integer> a = new ArrayList<Integer>();
                           Pair<Integer,String> p1 = new Pair<Integer,String>(1,x3);
                           for(Integer z: st.abstract_values.get(x2))
                           {
                              p1.first = z;
                              for(Integer z1: hn.abstract_values.get(p1))
                              {
                                 if(!a.contains(z1))
                                    a.add(z1);
                              }
                           }
                           ArrayList<Integer> av = st.abstract_values.get("this");
                           p1.second = x1;
                           if(av.size() == 1)
                           {
                              //strict update
                              t1.put(new Pair<Integer,String>(av.get(0),x1),a);
                           }
                           else
                           {
                              for(Integer z: av)
                              {
                                 p1.first = z;
                                 ArrayList<Integer> a2 = new ArrayList<Integer>();
                                 for(Integer z1: a)
                                    a2.add(z1);
                                 ArrayList<Integer> a3 = hn.abstract_values.get(p1);
                                 for(Integer z1: a3)
                                 {
                                    if(!a2.contains(z1))
                                       a2.add(z1);
                                 }
                                 t1.put(p1,a2);//weakly update the heap values for a write operation.
                              }
                           }
                           t = heap_meet(t, t1);
                        }
                        else if(stat.op == 'r')
                        {
                           //not clear which function is called. For safety, take static type and all it's subtypes
                           int k1;
                           String base_ty = get_type(x1);
                           ArrayList<Integer> a = new ArrayList<Integer>();
                           for(k1 = 0;k1 < object_alloc;k1++)
                           {
                              String ty = object_values.get(k1);
                              if(is_subtype(ty,base_ty))
                              {
                                 a.add(k1);
                              }
                           }
                           ArrayList<Integer> av = st.abstract_values.get("this");
                           Pair<Integer,String> p1 = new Pair<Integer,String>(1,x1);
                           if(av.size() == 1)
                           {
                              //strict update
                              t1.put(new Pair<Integer,String>(av.get(0),x1),a);
                           }
                           else
                           {
                              for(Integer z: av)
                              {
                                 p1.first = z;
                                 ArrayList<Integer> a2 = new ArrayList<Integer>();
                                 for(Integer z1: a)
                                    a2.add(z1);
                                 ArrayList<Integer> a3 = hn.abstract_values.get(p1);
                                 for(Integer z1: a3)
                                 {
                                    if(!a2.contains(z1))
                                       a2.add(z1);
                                 }
                                 t1.put(p1,a2);//weakly update the heap values for a write operation.
                              }
                           }
                           for(j = 3; j < stat.id_list.size();j++)
                           {
                              String id = stat.id_list.get(i);//arguments to be set
                              String ty_a = get_type(id);
                              if(!classes.containsKey(ty_a))
                                 continue;
                              a = new ArrayList<Integer>();
                              if(function_object.arguments.containsKey(id) || function_object.local_variables.containsKey(id))
                              {
                                 for(Integer z: st.abstract_values.get(id))
                                    a.add(z);
                              }
                              else
                              {
                                 p1 = new Pair<Integer,String>(1,id);
                                 for(Integer z: st.abstract_values.get("this"))
                                 {  
                                    p1.first = z;
                                    for(Integer z1: hn.abstract_values.get(p1))
                                    {
                                       if(!a.contains(z1))
                                          a.add(z1);
                                    }
                                 }
                              }
                              Hashtable<String,Boolean> ht = new Hashtable<String,Boolean>();
                              while(ty_a != null)
                              {
                                 ClassTable ct = classes.get(ty_a);
                                 for(Map.Entry<String,String> m: ct.class_fields.entrySet())
                                 {
                                    if(!classes.containsKey(m.getValue()))
                                       continue;
                                    String f_id = m.getKey();
                                    if(ht.contains(f_id))
                                       continue;
                                    ht.put(f_id,true);
                                    String bas_ty = m.getValue();
                                    ArrayList<Integer> upd_vals = new ArrayList<Integer>();
                                    for(k1=0;k1 < object_alloc;k1++)
                                    {
                                       String cur_ty = object_values.get(k1);
                                       if(is_subtype(cur_ty,bas_ty))
                                          upd_vals.add(k1);
                                    }
                                    p1 = new Pair<Integer,String>(1,f_id);
                                    for(Integer z: a)
                                    {
                                       p1.first = z;
                                       ArrayList<Integer> upd1 = new ArrayList<Integer>();
                                       for(Integer z1: upd_vals)
                                          upd1.add(z1);
                                       t1.put(p1,upd1);                             
                                    }
                                 }
                                 ty_a = ct.parent;
                              }
                           }
                           t = heap_meet(t, t1);
                        }
                        else
                        {
                           //for void message send or ordinary message send, heap alone changes. stack stays the same.
                           t = heap_meet(t,t1);
                        }
                        continue;
                     }

                     if(stat.op == '=')
                     {
                        String x2 = stat.id_list.get(1);
                        //pw.println(x2);
                        //outflow changes now. Simply update the lattice
                        ArrayList<Integer> a = new ArrayList<Integer>();
                        //pw.println(st.abstract_values);
                        if(st.abstract_values.containsKey(x2))
                        {
                           for(Integer z: st.abstract_values.get(x2))
                              a.add(z);
                        }
                        else
                        {
                           Pair<Integer,String> pa = new Pair<Integer,String>(1,x2);
                           for(Integer z: st.abstract_values.get("this"))
                           {
                              pa.first = z;
                              for(Integer z1: hn.abstract_values.get(pa))
                              {
                                 if(!a.contains(z1))
                                    a.add(z1);
                              }
                           }
                        }
                        h1.put(x1,a);//update
                        h = stack_meet(h, h1);
                     }
                     else if(stat.op == 'o')
                     {
                        //object allocation
                        String x2 = stat.id_list.get(1);//object address
                        ArrayList<Integer> a1 = new ArrayList<Integer>();
                        a1.add(Integer.parseInt(x2));
                        h1.put(x1, a1);
                        h = stack_meet(h, h1);
                     }
                     else if(stat.op == 'd')
                     {
                        //dot expression
                        String x2 = stat.id_list.get(1);
                        String x3 = stat.id_list.get(2);
                        ArrayList<Integer> v = new ArrayList<Integer>();
                        Pair<Integer,String> k = new Pair<Integer,String>(new Integer(1),x3);
                        for(Integer z: curr_stack_node.abstract_values.get(x2))
                        {
                           k.first = z;
                           for(Integer z1: curr_heap_node.abstract_values.get(k))
                           {
                              if(!v.contains(z1))
                                 v.add(z1);
                           }
                        }
                        h1.put(x1,v);
                        h = stack_meet(h,h1);
                     }
                     else if(stat.op == 'r')
                     {
                        //not clear which function is called. For safety, take static type and all it's subtypes
                        int k1;
                        String base_ty = get_type(x1);
                        ArrayList<Integer> nv = new ArrayList<Integer>();
                        for(k1 = 0;k1 < object_alloc;k1++)
                        {
                           String ty = object_values.get(k1);
                           if(is_subtype(ty,base_ty))
                           {
                              nv.add(k1);
                           }
                        }
                        h1.put(x1,nv);
                        h = stack_meet(h, h1);
                     }

                     else
                     {
                        h = stack_meet(h,h1);
                     }
                  }
                  else
                  {
                     h = stack_meet(h,h1);
                  }
               }

               for(HeapNode he: curr_heap_node.predecessors)
               {  
                  StackNode st = function_object.stack_values.get(function_object.heap_values.indexOf(he));
                  StatementNode stat = function_object.function_body.get(function_object.heap_values.indexOf(he));//corresponding statement
                  TreeMap<Pair<Integer,String>,ArrayList<Integer>> t1 = deep_heap_copy(he.abstract_values);
                  if(stat.op == 'f')
                  {
                     //field assignment statement,the only one that matters along with message send.
                     String x1 = stat.id_list.get(0);
                     String x2 = stat.id_list.get(1);
                     String x3 = stat.id_list.get(2);
                     ArrayList<Integer> a = new ArrayList<Integer>();
                     ArrayList<Integer> upd_vals = new ArrayList<Integer>();
                     String ty_ob = get_type(x1);
                     String ty_f = get_type(ty_ob,x2);
                     if(!classes.containsKey(ty_f))
                     {
                        //no update of heap
                        t = heap_meet(t, t1);
                        continue;
                     }
                     if(st.abstract_values.containsKey(x3))
                        upd_vals = st.abstract_values.get(x3);
                     else
                     {
                        Pair<Integer,String> p1 = new Pair<Integer,String>(1,x3);
                        for(Integer z: st.abstract_values.get("this"))
                        {
                           p1.first = z;
                           for(Integer z1: he.abstract_values.get(p1))
                           {
                              if(!upd_vals.contains(z1))
                                 upd_vals.add(z1);
                           }
                        }
                     }

                     if(function_object.local_variables.containsKey(x1) || function_object.arguments.containsKey(x1))
                     {
                        for(Integer z: st.abstract_values.get(x1))
                        {
                           a.add(z);
                        }
                     }
                     else
                     {
                        //class variable, but update is still a must.
                        Pair<Integer,String> p1 = new Pair<Integer,String>(1,x1);
                        for(Integer z: st.abstract_values.get("this"))
                        {
                           p1.first = z;
                           for(Integer z1: he.abstract_values.get(p1))
                           {
                              if(!a.contains(z1))
                                 a.add(z1);
                           }
                        }
                     }
                     int x = a.size();
                     if(x == 1)//strict update is now possible
                     {
                        Integer x11 = a.get(0);
                        t1.put(new Pair<Integer,String>(x11,x2),upd_vals); 
                     }
                     else
                     {
                        //more than one, so conservatively update everything
                        Pair<Integer,String> p1 = new Pair<Integer,String>(1,x2);
                        for(Integer z: st.abstract_values.get(x1))
                        {
                           p1.first = z;
                           ArrayList<Integer> a1 = new ArrayList<Integer>();
                           for(Integer z1: he.abstract_values.get(p1))
                              a1.add(z1);
                           for(Integer z1 : upd_vals)
                           {
                              if(!a1.contains(z1))
                                 a1.add(z1);
                           }
                           t1.put(p1,a1);//updated values
                        }
                     }
                     t = heap_meet(t,t1);
                  }
                  else if(stat.op == 'v')
                  {
                     int n0 = stat.id_list.size();
                     for(j = 2; j < stat.id_list.size();j++)
                     {
                        String id = stat.id_list.get(i);//arguments to be set
                        String ty_a = get_type(id);
                        if(!classes.containsKey(ty_a))
                           continue;
                        ArrayList<Integer> a = new ArrayList<Integer>();
                        if(function_object.arguments.containsKey(id) || function_object.local_variables.containsKey(id))
                        {
                           for(Integer z: st.abstract_values.get(id))
                              a.add(z);
                        }
                        else
                        {
                           Pair<Integer,String> p1 = new Pair<Integer,String>(1,id);
                           for(Integer z: st.abstract_values.get("this"))
                           {  
                              p1.first = z;
                              for(Integer z1: he.abstract_values.get(p1))
                              {
                                 if(!a.contains(z1))
                                    a.add(z1);
                              }
                           }
                        }
                        Hashtable<String,Boolean> ht = new Hashtable<String,Boolean>();
                        while(ty_a != null)
                        {
                           ClassTable ct = classes.get(ty_a);
                           for(Map.Entry<String,String> m: ct.class_fields.entrySet())
                           {
                              if(!classes.containsKey(m.getValue()))
                                 continue;
                              String f_id = m.getKey();
                              if(ht.contains(f_id))
                                 continue;
                              ht.put(f_id,true);
                              String bas_ty = m.getValue();
                              ArrayList<Integer> upd_vals = new ArrayList<Integer>();
                              for(int k1=0;k1 < object_alloc;k1++)
                              {
                                 String cur_ty = object_values.get(k1);
                                 if(is_subtype(cur_ty,bas_ty))
                                    upd_vals.add(k1);
                              }
                              Pair<Integer,String> p1 = new Pair<Integer,String>(1,f_id);
                              for(Integer z: a)
                              {
                                 p1.first = z;
                                 ArrayList<Integer> upd1 = new ArrayList<Integer>();
                                 for(Integer z1: upd_vals)
                                    upd1.add(z1);
                                 t1.put(p1,upd1);                             
                              }
                           }
                           ty_a = ct.parent;
                        }
                     }
                     t = heap_meet(t,t1);
                  }
                  else
                  {
                     t = heap_meet(t,t1);
                  } 
               }
               
               if(!stack_equal(curr_stack_node.abstract_values, h))
               {
                  change = true;
                  curr_stack_node.abstract_values = h;
               }
               if(!heap_equal(curr_heap_node.abstract_values, t))
               {
                  change = true;
                  curr_heap_node.abstract_values = t;
               }
            }
         }
         cnt++;
      }
      while(change);
      // pw.printf("%s_%s converged after %d iterations!\n",current_class,current_function,cnt);
      // cnt =  0;
      // for(StackNode n1: function_object.stack_values)
      // {  
      //    StatementNode n2 = function_object.function_body.get(cnt);
      //    HeapNode he = function_object.heap_values.get(cnt);
      //    pw.println(n1.abstract_values);
      //    pw.print("{");
      //    for(Map.Entry<Pair<Integer,String>,ArrayList<Integer>> m: he.abstract_values.entrySet())
      //    {
      //       Pair<Integer,String> p = m.getKey();
      //       ArrayList<Integer> a = m.getValue();
      //       pw.printf("(%d,%s) = [",p.first,p.second);
      //       for(Integer z: a)
      //          pw.printf("%d,",z);
      //       pw.printf("],");
      //    }
      //    pw.printf("}\n");
      //    pw.println(n2.op);
      //    cnt++;
      // }
   }
   
   public void visit(NodeList n, A argu) {
      int _count=0;
      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
         e.nextElement().accept(this,argu);
         _count++;
      }
   }

   public void visit(NodeListOptional n, A argu) {
      if ( n.present() ) {
         int _count=0;
         for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
            e.nextElement().accept(this,argu);
            _count++;
         }
      }
   }

   public void visit(NodeOptional n, A argu) {
      if ( n.present() )
         n.node.accept(this,argu);
   }

   public void visit(NodeSequence n, A argu) {
      int _count=0;
      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
         e.nextElement().accept(this,argu);
         _count++;
      }
   }

   public void visit(NodeToken n, A argu) {
      tokenName = n.tokenImage;
   }

   //
   // User-generated visitor methods below
   //

   /**
    * f0 -> MainClass()
    * f1 -> ( TypeDeclaration() )*
    * f2 -> <EOF>
    */
   public void visit(Goal n, A argu) {
      int arg = Integer.valueOf((Integer)argu);
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      if(arg == 1)
         generate_code();
   }

   /**
    * f0 -> "class"
    * f1 -> Identifier()
    * f2 -> "{"
    * f3 -> "public"
    * f4 -> "static"
    * f5 -> "void"
    * f6 -> "main"
    * f7 -> "("
    * f8 -> "String"
    * f9 -> "["
    * f10 -> "]"
    * f11 -> Identifier()
    * f12 -> ")"
    * f13 -> "{"
    * f14 -> ( VarDeclaration() )*
    * f15 -> ( Statement() )*
    * f16 -> "}"
    * f17 -> "}"
    */
   public void visit(MainClass n, A argu) {
      int a = Integer.valueOf((Integer)argu);
      if(a == 0)
      {
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
         current_class = tokenName;
         class_object = new ClassTable();
         current_function = "main";
         function_object = new FunctionTable();
         inline_locals = 0;
         inline = false;
         n.f2.accept(this, argu);
         n.f3.accept(this, argu);
         n.f4.accept(this, argu);
         n.f5.accept(this, argu);
         n.f6.accept(this, argu);
         n.f7.accept(this, argu);
         n.f8.accept(this, argu);
         n.f9.accept(this, argu);
         n.f10.accept(this, argu);
         n.f11.accept(this, argu);
         String arg_id = tokenName;
         function_object.arguments.put("this",current_class);
         function_object.arguments.put(arg_id,"String[]");
         function_object.return_type = "void";
         n.f12.accept(this, argu);
         n.f13.accept(this, argu);
         n.f14.accept(this, argu);
         n.f15.accept(this, argu);
         n.f16.accept(this, argu);
         class_object.functions.put("main",function_object);
         n.f17.accept(this, argu);
         classes.put(current_class,class_object);
         function_object = null;
         class_object = null;
         current_class = current_function = null;
      }
      else if(a == 1)
      {
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
         current_class = tokenName;
         main_class = tokenName; 
         class_object = classes.get(current_class);
         current_function = "main";
         function_object = class_object.functions.get("main");
         curr_stack_node = new StackNode();
         curr_heap_node = new HeapNode();
         current_statement = new StatementNode();
         current_statement.op = 'e';//entry BB
         stack_values = new ArrayList<StackNode>();
         heap_values = new ArrayList<HeapNode>();
         n.f2.accept(this, argu);
         n.f3.accept(this, argu);
         n.f4.accept(this, argu);
         n.f5.accept(this, argu);
         n.f6.accept(this, argu);
         n.f7.accept(this, argu);
         n.f8.accept(this, argu);
         n.f9.accept(this, argu);
         n.f10.accept(this, argu);
         n.f11.accept(this, argu);
         n.f12.accept(this, argu);
         n.f13.accept(this, argu);
         n.f14.accept(this, argu);
         function_object.function_body.add(current_statement);
         stack_values.add(curr_stack_node);
         heap_values.add(curr_heap_node);
         n.f15.accept(this, argu);
         n.f16.accept(this, argu);
         n.f17.accept(this, argu);
         StackNode ex_s = new StackNode();
         HeapNode ex_h = new HeapNode();
         ex_h.predecessors.add(curr_heap_node);
         ex_s.predecessors.add(curr_stack_node);
         curr_stack_node.successors.add(ex_s);
         curr_heap_node.successors.add(ex_h);
         StatementNode ex_st = new StatementNode();
         ex_st.op = 'x';//exit statement code
         function_object.function_body.add(ex_st);
         stack_values.add(ex_s);
         heap_values.add(ex_h);
         function_object.heap_values = heap_values;
         function_object.stack_values = stack_values;
         current_function = "main";
         conditional_prop();
         current_class = current_function = null;
         function_object = null;
         class_object = null;
      }
      else
      {

      }
   }

   /**
    * f0 -> ClassDeclaration()
    *       | ClassExtendsDeclaration()
    */
   public void visit(TypeDeclaration n, A argu) {
      n.f0.accept(this, argu);
   }

   /**
    * f0 -> "class"
    * f1 -> Identifier()
    * f2 -> "{"
    * f3 -> ( VarDeclaration() )*
    * f4 -> ( MethodDeclaration() )*
    * f5 -> "}"
    */
   public void visit(ClassDeclaration n, A argu) {
      int arg = Integer.valueOf((Integer)argu);
      if(arg == 0)
      {
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
         current_class = tokenName;
         class_object = new ClassTable();
         n.f2.accept(this, argu);
         n.f3.accept(this, argu);
         n.f4.accept(this, argu);
         n.f5.accept(this, argu);
         classes.put(current_class,class_object);
         class_object = null;
         current_class = null;
      }
      else if(arg == 1)
      {
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
         current_class = tokenName;
         class_object = classes.get(current_class);
         n.f2.accept(this, argu);
         n.f3.accept(this, argu);
         n.f4.accept(this, argu);
         n.f5.accept(this, argu);
         current_class = null;
         class_object = null;
      }
   }

   /**
    * f0 -> "class"
    * f1 -> Identifier()
    * f2 -> "extends"
    * f3 -> Identifier()
    * f4 -> "{"
    * f5 -> ( VarDeclaration() )*
    * f6 -> ( MethodDeclaration() )*
    * f7 -> "}"
    */
   public void visit(ClassExtendsDeclaration n, A argu) {
      int arg = Integer.valueOf((Integer)argu);
      if(arg == 0)
      {
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
         current_class = tokenName;
         class_object = new ClassTable();
         n.f2.accept(this, argu);
         n.f3.accept(this, argu);
         class_object.parent = tokenName;
         n.f4.accept(this, argu);
         n.f5.accept(this, argu);
         n.f6.accept(this, argu);
         n.f7.accept(this, argu);
         classes.put(current_class,class_object);
         current_class = null;
         class_object = null;
      }
      else if(arg == 1)
      {
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
         current_class = tokenName;
         class_object = classes.get(current_class);
         n.f2.accept(this, argu);
         n.f3.accept(this, argu);
         n.f4.accept(this, argu);
         n.f5.accept(this, argu);
         n.f6.accept(this, argu);
         n.f7.accept(this, argu);
         current_class = null;
         class_object = null;
      }
      else
      {

      }
   }

   /**
    * f0 -> Type()
    * f1 -> Identifier()
    * f2 -> ";"
    */
   public void visit(VarDeclaration n, A argu) {
      int arg = Integer.valueOf((Integer)argu);
      if(arg == 0)
      {
         n.f0.accept(this, argu);
         String ty = tokenName;
         n.f1.accept(this, argu);
         String id = tokenName;
         if(function_object == null)
            class_object.class_fields.put(id,ty);
         else
            function_object.local_variables.put(id,ty);
         n.f2.accept(this, argu);
      }
      else if(arg == 1)
      {
         n.f0.accept(this,argu);
         String ty = tokenName;
         n.f1.accept(this,argu);
         String id = tokenName;
         n.f2.accept(this, argu);
      }
      else
      {

      }
   }

   /**
    * f0 -> "public"
    * f1 -> Type()
    * f2 -> Identifier()
    * f3 -> "("
    * f4 -> ( FormalParameterList() )?
    * f5 -> ")"
    * f6 -> "{"
    * f7 -> ( VarDeclaration() )*
    * f8 -> ( Statement() )*
    * f9 -> "return"
    * f10 -> Identifier()
    * f11 -> ";"
    * f12 -> "}"
    */
   public void visit(MethodDeclaration n, A argu) {
      int arg = Integer.valueOf((Integer)argu);
      if(arg == 0)
      {
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
         String rt = tokenName;
         n.f2.accept(this, argu);
         current_function = tokenName;
         function_object = new FunctionTable();
         function_object.return_type = rt;
         function_object.arguments.put("this",current_class);//this pointer is like an argument given to every function
         n.f3.accept(this, argu);
         n.f4.accept(this, argu);
         n.f5.accept(this, argu);
         n.f6.accept(this, argu);
         n.f7.accept(this, argu);
         n.f8.accept(this, argu);
         n.f9.accept(this, argu);
         n.f10.accept(this, argu);
         function_object.return_id = tokenName;
         n.f11.accept(this, argu);
         n.f12.accept(this, argu);
         class_object.functions.put(current_function,function_object);
         function_object = null;
         current_function = null;
      }
      else if(arg == 1)
      {
         for_counter = 0;
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
         String rt = tokenName;
         n.f2.accept(this, argu);
         current_function = tokenName;
         function_object = class_object.functions.get(current_function);
         curr_heap_node = new HeapNode();
         curr_stack_node = new StackNode();
         stack_values = new ArrayList<StackNode>();
         heap_values = new ArrayList<HeapNode>();
         current_statement = new StatementNode();
         current_statement.op = 'e';//entry BB
         function_object.function_body.add(current_statement);
         n.f3.accept(this, argu);
         n.f4.accept(this, argu);
         n.f5.accept(this, argu);
         n.f6.accept(this, argu);
         n.f7.accept(this, argu);
         stack_values.add(curr_stack_node);
         heap_values.add(curr_heap_node);
         n.f8.accept(this, argu);
         n.f9.accept(this, argu);
         n.f10.accept(this, argu);
         function_object.return_id = tokenName;
         n.f11.accept(this, argu);
         n.f12.accept(this, argu);
         StackNode n1 = new StackNode();
         HeapNode n2 = new HeapNode();
         StatementNode n3 = new StatementNode();
         curr_heap_node.successors.add(n2);
         curr_stack_node.successors.add(n1);
         n1.predecessors.add(curr_stack_node);
         n2.predecessors.add(curr_heap_node);
         n3.op = 'x';
         n3.id_list.add(function_object.return_id);
         stack_values.add(n1);
         heap_values.add(n2);
         function_object.function_body.add(n3);
         function_object.stack_values = stack_values;
         function_object.heap_values = heap_values;
         class_object.functions.put(current_function,function_object);
         conditional_prop();
         function_object = null;
         current_function = null;
      }
      else
      {

      }
   }

   /**
    * f0 -> FormalParameter()
    * f1 -> ( FormalParameterRest() )*
    */
   public void visit(FormalParameterList n, A argu) {
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
   }

   /**
    * f0 -> Type()
    * f1 -> Identifier()
    */
   public void visit(FormalParameter n, A argu) {
      int arg = Integer.valueOf((Integer)argu);
      if(arg == 0)
      {
         n.f0.accept(this, argu);
         String ty = tokenName;
         n.f1.accept(this, argu);
         String id = tokenName;
         function_object.arguments.put(id,ty);
      }
      else if(arg == 1)
      {
         n.f0.accept(this,argu);
         String ty  = tokenName;
         n.f1.accept(this,argu);
         String id = tokenName;
      }
      else
      {

      }
   }

   /**
    * f0 -> ","
    * f1 -> FormalParameter()
    */
   public void visit(FormalParameterRest n, A argu) {
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
   }

   /**
    * f0 -> ArrayType()
    *       | BooleanType()
    *       | IntegerType()
    *       | Identifier()
    */
   public void visit(Type n, A argu) {
      n.f0.accept(this, argu);
   }

   /**
    * f0 -> "int"
    * f1 -> "["
    * f2 -> "]"
    */
   public void visit(ArrayType n, A argu) {
      int arg = Integer.valueOf((Integer)argu);
      if(arg == 0)
      {
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
         n.f2.accept(this, argu);
         type_of_expr = tokenName = "int[]";

      }
      else if(arg == 1)
      {
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
         n.f2.accept(this, argu);
         type_of_expr = tokenName = "int[]";
      }
      else
      {

      }
   }

   /**
    * f0 -> "boolean"
    */
   public void visit(BooleanType n, A argu) {
      int arg = Integer.valueOf((Integer)argu);
      if(arg == 0)
      {
         n.f0.accept(this, argu);
         type_of_expr = tokenName = "boolean";

      }
      else if(arg == 1)
      {
         n.f0.accept(this, argu);
         type_of_expr = tokenName = "boolean";
      }
      else
      {

      }
   }

   /**
    * f0 -> "int"
    */
   public void visit(IntegerType n, A argu) {
      int arg = Integer.valueOf((Integer)argu);
      if(arg == 0)
      {
         n.f0.accept(this, argu);
         type_of_expr = tokenName = "int";

      }
      else if(arg == 1)
      {
         n.f0.accept(this, argu);
         type_of_expr = tokenName = "int";
      }
      else
      {

      }
   }

   /**
    * f0 -> Block()
    *       | AssignmentStatement()
    *       | ArrayAssignmentStatement()
    *       | FieldAssignmentStatement()
    *       | IfStatement()
    *       | WhileStatement()
    *       | ForStatement()
    *       | PrintStatement()
    *       | MessageSendStatement()
    */
   public void visit(Statement n, A argu) {
      n.f0.accept(this, argu);
   }

   /**
    * f0 -> "{"
    * f1 -> ( Statement() )*
    * f2 -> "}"
    */
   public void visit(Block n, A argu) {
      int arg = Integer.valueOf((Integer)argu);
      if(arg <= 1)
      {
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
         n.f2.accept(this, argu);
      }
   }

   /**
    * f0 -> Identifier()
    * f1 -> "="
    * f2 -> RhsExpression()
    * f3 -> ";"
    */
   public void visit(AssignmentStatement n, A argu) {
      int arg = Integer.valueOf((Integer)argu);
      if(arg == 0)
      {
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
         n.f2.accept(this, argu);
         n.f3.accept(this, argu);
      }
      else if(arg == 1)
      {
         n.f0.accept(this, argu);
         String id = tokenName;
         StackNode n1 = new StackNode();
         HeapNode n2 = new HeapNode();
         n1.predecessors.add(curr_stack_node);
         curr_stack_node.successors.add(n1);
         n2.predecessors.add(curr_heap_node);
         curr_heap_node.successors.add(n2);
         stack_values.add(n1);
         heap_values.add(n2);
         curr_heap_node = n2;
         curr_stack_node = n1;
         String x = get_type(id);
         current_statement = new StatementNode();
         current_statement.is_assignment = true;
         current_statement.id_list.add(id);
         n.f1.accept(this, argu);
         n.f2.accept(this, argu);
         function_object.function_body.add(current_statement);
         n.f3.accept(this, argu);
      }
      else
      {

      }
   }

   /**
    * f0 -> Identifier()
    * f1 -> "["
    * f2 -> Identifier()
    * f3 -> "]"
    * f4 -> "="
    * f5 -> Identifier()
    * f6 -> ";"
    */
   public void visit(ArrayAssignmentStatement n, A argu) {
      int arg = Integer.valueOf((Integer)argu);
      if(arg == 0)
      {
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
         n.f2.accept(this, argu);
         n.f3.accept(this, argu);
         n.f4.accept(this, argu);
         n.f5.accept(this, argu);
         n.f6.accept(this, argu);
      }
      else if(arg == 1)
      {
         n.f0.accept(this, argu);
         String an = tokenName;
         n.f1.accept(this, argu);
         n.f2.accept(this, argu);
         String ind = tokenName;
         n.f3.accept(this, argu);
         n.f4.accept(this, argu);
         n.f5.accept(this, argu);
         String v = tokenName;
         StatementNode n3 = new StatementNode();
         n3.is_assignment = true;
         n3.op = 'a';//array assgt
         n3.id_list.add(an);
         n3.id_list.add(ind);
         n3.id_list.add(v);
         StackNode n1 = new StackNode();
         HeapNode n2 = new HeapNode();
         curr_stack_node.successors.add(n1);
         n1.predecessors.add(curr_stack_node);
         curr_heap_node.successors.add(n2);
         n2.predecessors.add(curr_heap_node);
         curr_stack_node = n1;
         curr_heap_node = n2;
         stack_values.add(n1);
         heap_values.add(n2);
         function_object.function_body.add(n3);
         //because arrays are all int[],no change again
         n.f6.accept(this, argu);
      }
      else
      {

      }
   }

   /**
    * f0 -> Identifier()
    * f1 -> "."
    * f2 -> Identifier()
    * f3 -> "="
    * f4 -> Identifier()
    * f5 -> ";"
    */
   public void visit(FieldAssignmentStatement n, A argu) {
      int arg = Integer.valueOf((Integer)argu);
      if(arg == 0)
      {
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
         n.f2.accept(this, argu);
         n.f3.accept(this, argu);
         n.f4.accept(this, argu);
         n.f5.accept(this, argu);
      }
      else if(arg == 1)
      {
         n.f0.accept(this, argu);
         String ob = tokenName;
         n.f1.accept(this, argu);
         n.f2.accept(this, argu);
         String fld = tokenName;
         n.f3.accept(this, argu);
         n.f4.accept(this, argu);
         String v = tokenName;
         StackNode n1 = new StackNode();
         HeapNode n2 = new HeapNode();
         current_statement = new StatementNode();
         current_statement.op = 'f';//field assignment statement
         current_statement.id_list.add(ob);
         current_statement.id_list.add(fld);
         current_statement.id_list.add(v);
         current_statement.is_assignment = true;
         n1.predecessors.add(curr_stack_node);
         n2.predecessors.add(curr_heap_node);
         curr_heap_node.successors.add(n2);
         curr_stack_node.successors.add(n1);
         curr_heap_node = n2;
         curr_stack_node = n1;
         stack_values.add(curr_stack_node);
         heap_values.add(curr_heap_node);
         function_object.function_body.add(current_statement);
         n.f5.accept(this, argu);
      }
      else
      {

      }
   }

   /**
    * f0 -> "if"
    * f1 -> "("
    * f2 -> Identifier()
    * f3 -> ")"
    * f4 -> Statement()
    * f5 -> "else"
    * f6 -> Statement()
    */
   public void visit(IfStatement n, A argu) {
      int arg = Integer.valueOf((Integer)argu);
      if(arg == 0)
      {
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
         n.f2.accept(this, argu);
         n.f3.accept(this, argu);
         n.f4.accept(this, argu);
         n.f5.accept(this, argu);
         n.f6.accept(this, argu);
      }
      else if(arg == 1)
      {
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
         n.f2.accept(this, argu);
         String id = tokenName;
         StatementNode n_if = new StatementNode();
         current_statement = n_if;
         current_statement.op = 'i';
         current_statement.id_list.add(id);
         function_object.function_body.add(current_statement);
         StackNode n1 = new StackNode();
         HeapNode n2 = new HeapNode();
         curr_stack_node.successors.add(n1);
         n1.predecessors.add(curr_stack_node);
         curr_heap_node.successors.add(n2);
         n2.predecessors.add(curr_heap_node);
         curr_stack_node = n1;
         curr_heap_node = n2;
         stack_values.add(n1);
         heap_values.add(n2);
         int os = function_object.function_body.size();
         n.f3.accept(this, argu);
         n.f4.accept(this, argu);
         n_if.condition_count1 = function_object.function_body.size()-os;
         StackNode n3 = curr_stack_node;
         HeapNode n4 = curr_heap_node;
         curr_stack_node = n1;
         curr_heap_node = n2;
         os = function_object.function_body.size();
         n.f5.accept(this, argu);
         n.f6.accept(this, argu);
         n_if.condition_count2 = function_object.function_body.size()-os;//forget about the join node here
         StackNode n5 = curr_stack_node;
         HeapNode n6 = curr_heap_node;
         StackNode fs = new StackNode();
         HeapNode fh  = new HeapNode();
         StatementNode fst = new StatementNode();
         fst.op = 'j';//join node of an if statement
         function_object.function_body.add(fst);
         n3.successors.add(fs);
         fs.predecessors.add(n3);
         n4.successors.add(fh);
         fh.predecessors.add(n4);
         n5.successors.add(fs);
         fs.predecessors.add(n5);
         n6.successors.add(fh);
         fh.predecessors.add(n6);
         curr_stack_node = fs;
         curr_heap_node = fh;
         stack_values.add(fs);
         heap_values.add(fh);
      }
      else
      {

      }
   }

   /**
    * f0 -> "while"
    * f1 -> "("
    * f2 -> Identifier()
    * f3 -> ")"
    * f4 -> Statement()
    */
   public void visit(WhileStatement n, A argu) {
      int arg = Integer.valueOf((Integer)argu);
      if(arg == 0)
      {
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
         n.f2.accept(this, argu);
         n.f3.accept(this, argu);
         n.f4.accept(this, argu);
      }
      else if(arg == 1)
      {
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
         n.f2.accept(this, argu);
         String id = tokenName;
         StatementNode n_w = new StatementNode();
         current_statement = n_w;
         current_statement.op = 'w';//while statement
         current_statement.id_list.add(id);
         StackNode n1 = new StackNode();
         HeapNode n2 = new HeapNode();
         curr_stack_node.successors.add(n1);
         curr_heap_node.successors.add(n2);
         n1.predecessors.add(curr_stack_node);
         n2.predecessors.add(curr_heap_node);
         stack_values.add(n1);
         heap_values.add(n2);
         curr_stack_node = n1;
         curr_heap_node = n2;
         function_object.function_body.add(current_statement);
         int os = function_object.function_body.size();
         n.f3.accept(this, argu);
         n.f4.accept(this, argu);
         curr_heap_node.successors.add(n2);
         curr_stack_node.successors.add(n1);
         n1.predecessors.add(curr_stack_node);
         n2.predecessors.add(curr_heap_node);
         curr_stack_node = n1;
         curr_heap_node = n2;
         n_w.condition_count1 = function_object.function_body.size()-os;
      }
      else
      {

      }
   }

   /**
    * f0 -> "for"
    * f1 -> "("
    * f2 -> Identifier()
    * f3 -> "="
    * f4 -> Expression()
    * f5 -> ";"
    * f6 -> Expression()
    * f7 -> ";"
    * f8 -> Identifier()
    * f9 -> "="
    * f10 -> Expression()
    * f11 -> ")"
    * f12 -> Statement()
    */
   public void visit(ForStatement n, A argu) {
      int arg = Integer.valueOf((Integer)argu);
      if(arg == 0)
      {
         //generate a temporary for each while loop, only way out!
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
         n.f2.accept(this, argu);
         n.f3.accept(this, argu);
         n.f4.accept(this, argu);
         n.f5.accept(this, argu);
         n.f6.accept(this, argu);
         n.f7.accept(this, argu);
         n.f8.accept(this, argu);
         n.f9.accept(this, argu);
         n.f10.accept(this, argu);
         n.f11.accept(this, argu);
         n.f12.accept(this, argu);
      }
      else if(arg == 1)
      {
         function_object.local_variables.put(String.format("__for__local%d",for_counter),"boolean");
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
         n.f2.accept(this, argu);
         String id = tokenName;
         StatementNode n1 = new StatementNode();
         StackNode a1 = new StackNode();
         HeapNode a2 = new HeapNode();
         a1.predecessors.add(curr_stack_node);
         curr_stack_node.successors.add(a1);
         a2.predecessors.add(curr_heap_node);
         curr_heap_node.successors.add(a2);
         stack_values.add(a1);
         heap_values.add(a2);
         curr_heap_node = a2;
         curr_stack_node = a1;
         n1.is_assignment = true;
         n1.id_list.add(id);
         current_statement = n1;
         n.f3.accept(this, argu);
         n.f4.accept(this, argu);
         n.f5.accept(this, argu);
         function_object.function_body.add(current_statement);
         //add an assignment statement for the temporary identifier
         StackNode a3 = new StackNode();
         HeapNode a4 = new HeapNode();
         StatementNode n2 = new StatementNode();
         n2.is_assignment = true;
         n2.id_list.add(String.format("__for__local%d",for_counter));
         a3.predecessors.add(curr_stack_node);
         curr_stack_node.successors.add(a3);
         a4.predecessors.add(curr_heap_node);
         curr_heap_node.successors.add(a4);
         curr_stack_node = a3;
         curr_heap_node = a4;
         stack_values.add(a3);
         heap_values.add(a4);
         function_object.function_body.add(n2);
         current_statement = n2;
         n.f6.accept(this, argu);
         n.f7.accept(this, argu);
         n.f8.accept(this, argu);
         String id_up = tokenName;
         StatementNode up_stm = new StatementNode();
         StackNode up_s = new StackNode();
         HeapNode up_h = new HeapNode();
         up_stm.is_assignment = true;
         up_stm.id_list.add(id_up);
         current_statement = up_stm;
         curr_stack_node = up_s;
         curr_heap_node = up_h;
         n.f9.accept(this, argu);
         n.f10.accept(this, argu);
         n.f11.accept(this, argu);
         StatementNode cond_n = new StatementNode();
         StackNode cond_s = new StackNode();
         HeapNode cond_h = new HeapNode();
         cond_s.predecessors.add(a3);
         a3.successors.add(cond_s);
         cond_h.predecessors.add(a4);
         a4.successors.add(cond_h);
         cond_n.op = 'w';
         cond_n.id_list.add(String.format("__for__local%d",for_counter));
         function_object.function_body.add(cond_n);
         stack_values.add(cond_s);
         heap_values.add(cond_h);
         int os = function_object.function_body.size();
         current_statement = cond_n;
         curr_heap_node = cond_h;
         curr_stack_node = cond_s;
         n.f12.accept(this, argu);
         function_object.function_body.add(up_stm);
         stack_values.add(up_s);
         heap_values.add(up_h);
         curr_stack_node.successors.add(up_s);
         curr_heap_node.successors.add(up_h);
         up_s.predecessors.add(curr_stack_node);
         up_h.predecessors.add(curr_heap_node);
         StackNode rep_a = new StackNode();
         HeapNode rep_b = new HeapNode();
         function_object.function_body.add(n2);//the statement node associated is the exact same that will be used in the computation of flow
         stack_values.add(rep_a);
         heap_values.add(rep_b);
         up_s.successors.add(rep_a);
         up_h.successors.add(rep_b);
         rep_a.predecessors.add(up_s);
         rep_b.predecessors.add(up_h);
         rep_a.successors.add(cond_s);
         rep_b.successors.add(cond_h);
         cond_s.predecessors.add(rep_a);
         cond_h.predecessors.add(rep_b);
         curr_heap_node = cond_h;
         curr_stack_node = cond_s;
         current_statement = cond_n;//doesn't really matter much
         cond_n.condition_count1 = function_object.function_body.size() - os;//for loop statement count
         for_counter++;
      }
      else
      {

      }
   }

   /**
    * f0 -> "System.out.println"
    * f1 -> "("
    * f2 -> Identifier()
    * f3 -> ")"
    * f4 -> ";"
    */
   public void visit(PrintStatement n, A argu) {
      int arg = Integer.valueOf((Integer)argu);
      if(arg == 0)
      {
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
         n.f2.accept(this, argu);
         n.f3.accept(this, argu);
         n.f4.accept(this, argu);
      }
      else if(arg == 1)
      {
         StatementNode n1 = new StatementNode();
         StackNode s = new StackNode();
         HeapNode h = new HeapNode();
         curr_heap_node.successors.add(h);
         curr_stack_node.successors.add(s);
         s.predecessors.add(curr_stack_node);
         h.predecessors.add(curr_heap_node);
         curr_stack_node = s;
         curr_heap_node = h;
         n1.op = 'p';//print statement
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
         n.f2.accept(this, argu);
         n1.id_list.add(tokenName);
         n.f3.accept(this, argu);
         n.f4.accept(this, argu);
         function_object.function_body.add(n1);
         stack_values.add(s);
         heap_values.add(h);
      }
      else
      {

      }
   }

   /**
    * f0 -> ( InlineAnn() )?
    * f1 -> ( VoidMessageSendStmt() | RetMessageSendStmt() )
    */
   public void visit(MessageSendStatement n, A argu) {
      n.f0.accept(this, argu);
      if(n.f0.present())
         inline = true;
      n.f1.accept(this, argu);
      inline = false;
   }

   /**
    * f0 -> MessageSend()
    * f1 -> ";"
    */
   public void visit(VoidMessageSendStmt n, A argu) {
      int arg = Integer.valueOf((Integer)argu);
      if(arg == 0)
      {
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
      }
      else if(arg == 1)
      {
         StatementNode n1 = new StatementNode();
         n1.op = 'v';//void message send statement
         n1.inline_req = inline;
         StackNode a = new StackNode();
         HeapNode b = new HeapNode();
         curr_stack_node.successors.add(a);
         a.predecessors.add(curr_stack_node);
         curr_heap_node.successors.add(b);
         b.predecessors.add(curr_heap_node);
         curr_heap_node = b;
         curr_stack_node = a;
         function_object.function_body.add(n1);
         current_statement = n1;
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
      }
      else
      {

      }
   }

   /**
    * f0 -> Identifier()
    * f1 -> "="
    * f2 -> MessageSend()
    * f3 -> ";"
    */
   public void visit(RetMessageSendStmt n, A argu) {
      int arg = Integer.valueOf((Integer)argu);
      if(arg == 0)
      {
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
         n.f2.accept(this, argu);
         n.f3.accept(this, argu);
      }
      else if(arg == 1)
      {
         StatementNode n1 = new StatementNode();
         StackNode n2  = new StackNode();
         HeapNode n3 = new HeapNode();
         curr_heap_node.successors.add(n3);
         curr_stack_node.successors.add(n2);
         n3.predecessors.add(curr_heap_node);
         n2.predecessors.add(curr_stack_node);
         curr_heap_node = n3;
         curr_stack_node = n2;
         stack_values.add(curr_stack_node);
         heap_values.add(curr_heap_node);
         n1.is_assignment = true;
         n1.op = 'r';//return message send
         n1.inline_req = inline;
         n.f0.accept(this, argu);
         n1.id_list.add(tokenName);
         function_object.function_body.add(n1);
         current_statement = n1;
         n.f1.accept(this, argu);
         n.f2.accept(this, argu);
         n.f3.accept(this, argu);
         //if the return value is that of an object type, store the abstract return values conservatively
      }
   }

   /**
    * f0 -> <SCOMMENT1>
    * f1 -> <INLINE>
    * f2 -> <SCOMMENT2>
    */
   public void visit(InlineAnn n, A argu) {
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
   }

   /** 
     * f0 -> DotExpression()
             | Expression()
    */
    public void visit(RhsExpression n,A argu)
    {
       n.f0.accept(this,argu);
    }
    /**
     * f0 -> Identifier()
     * f1 -> "."
     * f2 -> Identifier()
     */
    public void visit(DotExpression n,A argu)
    {
       int arg = Integer.valueOf((Integer)argu);
       if(arg == 0)
       {
         n.f0.accept(this,argu);
         n.f1.accept(this,argu);
         n.f2.accept(this,argu);
       }
       else if(arg == 1)
       {
         current_statement.op = 'd';
         n.f0.accept(this,argu);
         current_statement.id_list.add(tokenName);
         n.f1.accept(this,argu);
         n.f2.accept(this,argu);
         current_statement.id_list.add(tokenName);
       }
       else
       {

       } 
    }

   /**
    * f0 -> AndExpression()
    *       | CompareExpression()
    *       | PlusExpression()
    *       | MinusExpression()
    *       | TimesExpression()
    *       | ArrayLookup()
    *       | ArrayLength()
    *       | PrimaryExpression()
    */
   public void visit(Expression n, A argu) {
      n.f0.accept(this, argu);
   }

   /**
    * f0 -> Identifier()
    * f1 -> "&"
    * f2 -> Identifier()
    */
   public void visit(AndExpression n, A argu) {
      int arg = Integer.valueOf((Integer)argu);
      if(arg == 0)
      {
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
         n.f2.accept(this, argu);
      }
      else if(arg == 1)
      {
         current_statement.op = '&';
         n.f0.accept(this, argu);
         current_statement.id_list.add(tokenName);
         n.f1.accept(this, argu);
         n.f2.accept(this, argu);
         current_statement.id_list.add(tokenName);
      }
      else
      {

      }
   }

   /**
    * f0 -> Identifier()
    * f1 -> "<"
    * f2 -> Identifier()
    */
   public void visit(CompareExpression n, A argu) {
      int arg = Integer.valueOf((Integer)argu);
      if(arg == 0)
      {
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
         n.f2.accept(this, argu);
      }
      else if(arg == 1)
      {
         current_statement.op = '<';
         n.f0.accept(this, argu);
         current_statement.id_list.add(tokenName);
         n.f1.accept(this, argu);
         n.f2.accept(this, argu);
         current_statement.id_list.add(tokenName);
      }
      else
      {
         
      }
   }

   /**
    * f0 -> Identifier()
    * f1 -> "+"
    * f2 -> Identifier()
    */
   public void visit(PlusExpression n, A argu) {
      int arg = Integer.valueOf((Integer)argu);
      if(arg == 0)
      {
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
         n.f2.accept(this, argu);
      }
      else if(arg == 1)
      {
         current_statement.op = '+';
         n.f0.accept(this, argu);
         current_statement.id_list.add(tokenName);
         n.f1.accept(this, argu);
         n.f2.accept(this, argu);
         current_statement.id_list.add(tokenName);
      }
      else
      {
         
      }
   }

   /**
    * f0 -> Identifier()
    * f1 -> "-"
    * f2 -> Identifier()
    */
   public void visit(MinusExpression n, A argu) {
      int arg = Integer.valueOf((Integer)argu);
      if(arg == 0)
      {
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
         n.f2.accept(this, argu);
      }
      else if(arg == 1)
      {
         current_statement.op = '-';
         n.f0.accept(this, argu);
         current_statement.id_list.add(tokenName);
         n.f1.accept(this, argu);
         n.f2.accept(this, argu);
         current_statement.id_list.add(tokenName);
      }
      else
      {
         
      }
   }

   /**
    * f0 -> Identifier()
    * f1 -> "*"
    * f2 -> Identifier()
    */
   public void visit(TimesExpression n, A argu) {
      int arg = Integer.valueOf((Integer)argu);
      if(arg == 0)
      {
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
         n.f2.accept(this, argu);
      }
      else if(arg == 1)
      {
         current_statement.op = '*';
         n.f0.accept(this, argu);
         current_statement.id_list.add(tokenName);
         n.f1.accept(this, argu);
         n.f2.accept(this, argu);
         current_statement.id_list.add(tokenName);
      }
      else
      {
         
      }
   }

   /**
    * f0 -> Identifier()
    * f1 -> "["
    * f2 -> Identifier()
    * f3 -> "]"
    */
   public void visit(ArrayLookup n, A argu) {
      int arg = Integer.valueOf((Integer)argu);
      if(arg == 0)
      {
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
         n.f2.accept(this, argu);
         n.f3.accept(this, argu);
      }
      else if(arg == 1)
      {
         current_statement.op = '[';
         n.f0.accept(this, argu);
         current_statement.id_list.add(tokenName);
         n.f1.accept(this, argu);
         n.f2.accept(this, argu);
         current_statement.id_list.add(tokenName);
         n.f3.accept(this, argu);
      }  
      else
      {

      }
   }

   /**
    * f0 -> Identifier()
    * f1 -> "."
    * f2 -> "length"
    */
   public void visit(ArrayLength n, A argu) {
      int arg = Integer.valueOf((Integer)argu);
      if(arg == 0)
      {
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
         n.f2.accept(this, argu);
      }
      else if(arg == 1)
      {
         current_statement.op = 'l';
         n.f0.accept(this, argu);
         current_statement.id_list.add(tokenName);
         n.f1.accept(this, argu);
         n.f2.accept(this, argu);
      }
      else
      {  

      }
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "."
    * f2 -> Identifier()
    * f3 -> "("
    * f4 -> ( ArgList() )?
    * f5 -> ")"
    */
   public void visit(MessageSend n, A argu) {
      int arg = Integer.valueOf((Integer)argu);
      if(arg == 0)
      {
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
         n.f2.accept(this, argu);
         n.f3.accept(this, argu);
         n.f4.accept(this, argu);
         n.f5.accept(this, argu);
      }
      else if(arg == 1)
      {
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
         n.f2.accept(this, argu);
         current_statement.id_list.add(tokenName);
         n.f3.accept(this, argu);
         n.f4.accept(this, argu);
         n.f5.accept(this, argu);
      }
      else
      {

      }
   }

   /**
    * f0 -> Identifier()
    * f1 -> ( ArgRest() )*
    */
   public void visit(ArgList n, A argu) {
      int arg = Integer.valueOf((Integer)argu);
      if(arg == 0)
      {
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
      }
      else if(arg == 1)
      {
         n.f0.accept(this, argu);
         current_statement.id_list.add(tokenName);
         n.f1.accept(this, argu);
      }
   }

   /**
    * f0 -> ","
    * f1 -> Identifier()
    */
   public void visit(ArgRest n, A argu) {
      int arg = Integer.valueOf((Integer)argu);
      if(arg == 0)
      {
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
      }
      else if(arg == 1)
      {
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
         current_statement.id_list.add(tokenName);
      }
   }

   /**
    * f0 -> IntegerLiteral()
    *       | TrueLiteral()
    *       | FalseLiteral()
    *       | Identifier()
    *       | ThisExpression()
    *       | ArrayAllocationExpression()
    *       | AllocationExpression()
    *       | NotExpression()
    */
   public void visit(PrimaryExpression n, A argu) {
      int arg = Integer.valueOf((Integer)argu);
      n.f0.accept(this, argu);
      if(arg == 1)
      {
         if((n.f0.which == 3)|| (n.f0.which == 4))
         {
            //add the identifier to the id_list
            if(current_statement.op != 'r' && current_statement.op != 'v')
               current_statement.op = '=';//simple assignment
            current_statement.id_list.add(tokenName);
         }
      }
   }

   /**
    * f0 -> <INTEGER_LITERAL>
    */
   public void visit(IntegerLiteral n, A argu) {
      int arg = Integer.valueOf((Integer)argu);
      n.f0.accept(this, argu);
      if(arg == 1)
         current_statement.id_list.add(tokenName);
   }

   /**
    * f0 -> "true"
    */
   public void visit(TrueLiteral n, A argu) {
      int arg = Integer.valueOf((Integer)argu);
      n.f0.accept(this, argu);
      if(arg == 1)
         current_statement.id_list.add(tokenName);
   }

   /**
    * f0 -> "false"
    */
   public void visit(FalseLiteral n, A argu) {
      int arg = Integer.valueOf((Integer)argu);
      n.f0.accept(this, argu);
      if(arg == 1)
         current_statement.id_list.add(tokenName);
   }

   /**
    * f0 -> <IDENTIFIER>
    */
   public void visit(Identifier n, A argu) {
      n.f0.accept(this, argu);//do not disturb this production alone.
   }

   /**
    * f0 -> "this"
    */
   public void visit(ThisExpression n, A argu) {
      int arg = Integer.valueOf((Integer)argu);
      n.f0.accept(this, argu);
      if((arg == 1) && (current_statement.op != 'r') && (current_statement.op != 'v'))
         current_statement.id_list.add("this");
   }

   /**
    * f0 -> "new"
    * f1 -> "int"
    * f2 -> "["
    * f3 -> Identifier()
    * f4 -> "]"
    */
   public void visit(ArrayAllocationExpression n, A argu) {
      int arg = Integer.valueOf((Integer)argu);
      if(arg == 0)
      {
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
         n.f2.accept(this, argu);
         n.f3.accept(this, argu);
         n.f4.accept(this, argu);
      }
      else if(arg == 1)
      {
         current_statement.op = 'z';
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
         n.f2.accept(this, argu);
         n.f3.accept(this, argu);
         current_statement.id_list.add(tokenName);
         n.f4.accept(this, argu);
      }
      else
      {

      }
   }

   /**
    * f0 -> "new"
    * f1 -> Identifier()
    * f2 -> "("
    * f3 -> ")"
    */
   public void visit(AllocationExpression n, A argu) {
      int arg = Integer.valueOf((Integer)argu);
      if(arg == 0)
      {
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
         n.f2.accept(this, argu);
         n.f3.accept(this, argu);
      }
      else if(arg == 1)
      {
         if(current_statement.op == '~')
            current_statement.op = 'o';
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
         object_values.put(object_alloc,tokenName);
         current_statement.id_list.add(Integer.toString(object_alloc));//which abstract value?
         n.f2.accept(this, argu);
         n.f3.accept(this, argu);
         object_alloc++;
      }
      else
      {

      }
   }

   /**
    * f0 -> "!"
    * f1 -> Identifier()
    */
   public void visit(NotExpression n, A argu) {
      int arg = Integer.valueOf((Integer)argu);
      if(arg == 0)
      {
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
      }
      else if(arg == 1)
      {
         current_statement.op = '!';
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
         current_statement.id_list.add(tokenName);
      }
      else
      {

      }
   }

}
